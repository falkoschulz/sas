<!DOCTYPE html>
<!--
Copyright 2018 SAS Institute Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
  <head>
    <!-- Import D3.js -->
    <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/javascript" src="chroma.min.cjs"></script>
    <!-- Import font awesome -->
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
      integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU"
      crossorigin="anonymous"
    />

    <!-- Import utilities  -->
    <script type="text/javascript" src="../util/messagingUtil.js"></script>
    <script type="text/javascript" src="../util/contentUtil.js"></script>
  </head>
  <body>
    <style type="text/css">
      html,
      body,
      svg {
        float: left;
        min-width: 300px;
        min-height: 200px;
        margin: 0px;
        width: 100%;
        height: 100%;
      }

      text {
        font-family: Verdana, sans-serif;
      }

      .data-path {
        pointer-events: none;
        stroke-width: 2;
      }

      .data-point {
        cursor: pointer;
      }

      .legend-title {
        font-size: 0.9em;
        font-weight: bold;
        text-anchor: middle;
        alignment-baseline: hanging;
      }

      .g-legend-entry {
        cursor: pointer;
      }

      .legend-text,
      .measure-label {
        font-size: 0.8em;
        alignment-baseline: hanging;
      }

      .g-legend-entry.selected .legend-text {
        font-weight: bold;
      }

      .g-legend-entry.selected .legend-rect {
        stroke-width: 2px;
      }

      .tip {
        position: absolute;
        display: inline-block;
        overflow: hidden;
        background: white;
        border: 1px solid #c4c4c4;
        box-shadow: 3px 3px 3px #444444;
        border-radius: 2px;
      }

      .tip-close {
        color: #a4a4a4;
        position: absolute;
        cursor: pointer;
        right: 5px;
      }

      .tip-close:hover {
        color: #444444;
      }

      .tip-content {
        margin-top: 10px;
        white-space: nowrap;
        font-family: Verdana, sans-serif;
        font-size: 0.8em;
        text-align: left;
      }
    </style>

    <script>
      "use strict";

      function removeSpecialCharacters(str) {
        return str.replace(/[^a-zA-Z0-9]/g, "");
      }

      document.addEventListener("DOMContentLoaded", function () {
        /******************************************************* Declare variables *******************************************************/

        // Static data variables
        const SVG_ID = "split-radar"; // ID of SVG element
        const SAMPLE_MESSAGE = {
          version: "1",
          resultName: "dd260",
          rowCount: 18,
          availableRowCount: 18,
          data: [
            ["Hybrid", "Cylinders", 3.6666666666666665, "BEST12.", "Split", 1],
            ["Hybrid", "MPG (City)", 55, "BEST12.", "Split", 1],
            ["Hybrid", "MSRP", 19920, "DOLLAR8.", "Split", 1],
            ["Sedan", "Cylinders", 5.580152671755725, "BEST12.", "Split", 1],
            ["Sedan", "MPG (City)", 21.083969465648856, "BEST12.", "Split", 1],
            ["Sedan", "MSRP", 29773.618320610687, "DOLLAR8.", "Split", 1],
            ["Sports", "Cylinders", 6.340425531914893, "BEST12.", "Single", 0],
            [
              "Sports",
              "MPG (City)",
              18.408163265306122,
              "BEST12.",
              "Single",
              0,
            ],
            ["Sports", "MSRP", 53387.06122448979, "DOLLAR8.", "Single", 0],
            ["SUV", "Cylinders", 6.566666666666666, "BEST12.", "Single", 0],
            ["SUV", "MPG (City)", 16.1, "BEST12.", "Single", 0],
            ["SUV", "MSRP", 34790.25, "DOLLAR8.", "Single", 0],
            ["Truck", "Cylinders", 6.25, "BEST12.", "Split", 1],
            ["Truck", "MPG (City)", 16.5, "BEST12.", "Split", 1],
            ["Truck", "MSRP", 24941.375, "DOLLAR8.", "Split", 1],
            ["Wagon", "Cylinders", 5.3, "BEST12.", "Single", 0],
            ["Wagon", "MPG (City)", 21.1, "BEST12.", "Single", 0],
            ["Wagon", "MSRP", 28840.533333333333, "DOLLAR8.", "Single", 0],
          ],
          columns: [
            {
              name: "bi261",
              label: "Type",
              type: "string",
            },
            {
              name: "bi262",
              label: "Metric",
              type: "string",
            },
            {
              name: "bi263",
              label: "Measure",
              type: "number",
              usage: "quantitative",
              aggregation: "sum",
              format: {
                name: "BEST",
                width: 12,
                precision: 0,
                formatString: "BEST12.",
              },
            },
            {
              name: "bi264",
              label: "Format",
              type: "string",
            },
            {
              name: "bi265",
              label: "View",
              type: "string",
            },
            {
              name: "ri1",
              type: "number",
              usage: "brush",
              format: {
                name: "COMMA",
                width: 12,
                precision: 2,
                formatString: "COMMA12.2",
              },
            },
          ],
        }; // Sample data message to render graph outside of VA for debugging
        const OPACITY = {
          fill: {
            focus: 0.6,
            default: 0.2,
            unfocus: 0.1,
          },
          stroke: {
            focus: 1,
            default: 0.6,
            unfocus: 0.2,
          },
        }; // Various opacity values used during rendering
        const FILL = {}; // Fill colors keyed to labels
        const STROKE = {}; // Stroke colors keyed to labels

        // Dynamic data variables
        let VA_MESSAGE; // Data message to be received from VA
        let VA_RESULT_NAME; // Result name required to send messages back to VA
        let SPLIT; // Boolean indicating whether graph should be rendered in split mode
        let DATA; // Data to be parsed from VA data message
        let OLD_DATA; // Data from previous render to track duplicate point
        let METADATA = []; // Metadata to be parsed from VA data message
        let OLD_METADATA; // Metadata from previous render to track duplicate point
        let SELECTED_CATEGORY; // Currently selected category
        let LAST_TRANSITION_END = Date.now(); // Time of last transition used to time transition callbacks

        // Static dimension variables
        const TRANS_TIME = 500; // Duration of major transitions
        const TRANS_DELAY = 20; // Small buffer to ensure all callbacks have finished before allowing new transition
        const HOVER_TRANS_TIME = 100; // Duration of focus transitions
        const ENTER_REMOVE_TRANS_TIME = 200; // Duration of enter and exit transitions for data points and grid lines
        const TIP_TRANS_TIME = 250; // Duration of tooltip transitions
        const TILE_MIN_WIDTH = 150;
        const TILE_MIN_HEIGHT = 150;
        const MEASURE_LABEL_PADDING = 10; // Padding between edge of radar chart and measure labels
        const LEG_TITLE_PAD = 5; // Padding between legend title bottom and first row of legend
        const LEG_ROW_PAD = 3; // Padding between legend rows
        const LEG_RECT_WIDTH = 12; // Width of legend rects
        const LEG_RECT_PAD = 5; // Padding between legend rect and legend text
        const LEG_TEXT_PAD = 5; // Padding after legend text

        // Dynamic dimension variables
        let WIDTH; // Width of SVG element
        let HEIGHT; // Height of SVG element
        let GRID_WIDTH;
        let GRID_HEIGHT;
        let TILE_WIDTH;
        let TILE_HEIGHT;
        let LEG_EL_POS; // Positions of legend text elements
        let LEG_HEIGHT; // Height allocated for legend
        let RADIUS; // Radius of radar chart
        let OLD_RADIUS; // Previous radius of chart used for tweening height changes
        let DELTA_ANGLE; // Angle in radians between each measure on circle
        let TOP_PAD; // Vertical padding for measure labels
        let SIDE_PAD; // Horizontal padding for measure labels

        // Selection and d3 variables
        const COLOR_SCALE = d3.scaleOrdinal(d3.schemeSet2); // Ordinal color scale as backup
        const SCALED_FORMAT = d3.format("3.0f"); // Format for scaled version of measure displayed in tooltip
        d3.selection.prototype.moveToFront = function () {
          return this.each(function () {
            this.parentNode.appendChild(this);
          });
        }; // Bring element to front of SVG (from https://github.com/wbkd/d3-extended)
        let SVG; // SVG selection
        let DEFS; // Defs element selection
        let G_LEGEND; // Axis label data-join
        let GRADIENTS; // Gradients data-join
        let CATEGORY_GROUPS; // Category groups data-join
        let GRID_LINES; // Grid lines data-join
        let GRID_CIRCLES; // Grid circles data-join
        let MEASURE_LABELS; // Measure labels data-join
        let DATA_PATHS; // Data paths data-join
        let DATA_POINTS; // Data points data-join
        let LEGEND_TITLE; // Legend title data-join
        let LEGEND_GROUPS; // Legend groups data-join
        let TIPS; // Tooltips data-join

        /*************************************************** Setup Callback Functions ***************************************************/

        // Attach event for data message from VA
        va.messagingUtil.setOnDataReceivedCallback(handleCallback);

        // If not being rendered in iFrame (outside VA), render with sample data
        if (!inIframe()) {
          onDataReceived(SAMPLE_MESSAGE);
        }

        // Listen for resize event
        va.contentUtil.setupResizeListener(drawElements);

        /****************************************************** Callback Functions ******************************************************/

        // Use timeouts to debounce update events
        function handleCallback(messageFromVA) {
          if (LAST_TRANSITION_END > Date.now()) {
            setTimeout(function () {
              onDataReceived(messageFromVA);
            }, LAST_TRANSITION_END - Date.now());
            LAST_TRANSITION_END =
              LAST_TRANSITION_END + TRANS_TIME + TRANS_DELAY;
          } else {
            onDataReceived(messageFromVA);
            LAST_TRANSITION_END = Date.now() + TRANS_TIME + TRANS_DELAY;
          }
        }

        // Take action on received data
        function onDataReceived(messageFromVA) {
          // Initialize data variables
          VA_MESSAGE = messageFromVA;
          VA_RESULT_NAME = messageFromVA.resultName;

          // Validate data roles
          if (
            !va.contentUtil.validateRoles(messageFromVA, [
              "string",
              "string",
              "number",
              "string",
              "string",
              "number",
            ])
          ) {
            va.messagingUtil.postInstructionalMessage(
              VA_RESULT_NAME,
              "D3 Radar Chart expects columns to be assigned in this order:\n" +
                " 1. Category (string)\n" +
                " 2. Metric (string)\n" +
                " 3. Measure (number)\n" +
                " 4. Format (string)\n" +
                " 5. View (string)\n" +
                " 6. View Selection (from linked selection) (number)"
            );
            return;
          }

          // Determine whether or not radar should be split based on selection
          SPLIT =
            (VA_MESSAGE.data[0][4] == "Split" && VA_MESSAGE.data[0][5] == 1) ||
            (VA_MESSAGE.data[0][4] == "Single" && VA_MESSAGE.data[0][5] == 0);

          // Create nest to help process tall data structure
          const nestedData = d3
            .nest()
            .key(function (d) {
              return d[1];
            })
            .entries(VA_MESSAGE.data);
          const numMeasures = nestedData.length;

          // Restructure metadata from data message
          OLD_METADATA = METADATA;
          DELTA_ANGLE = (2 * Math.PI) / numMeasures;

          METADATA = {
            category: VA_MESSAGE.columns[0].label,
            metrics: {},
          };

          let totalMax = Number.MIN_VALUE;
          for (let i = 0; i < numMeasures; i++) {
            const maximum = d3.max(VA_MESSAGE.data, function (d) {
              if (d[1] == nestedData[i].key) {
                return d[2];
              } else {
                return Number.MIN_VALUE;
              }
            });
            METADATA.metrics[nestedData[i].key] = {
              metric: nestedData[i].key,
              angle: i * DELTA_ANGLE,
              format: translateFormat(VA_MESSAGE.data[i][3]),
              maximum,
            };

            if (totalMax < maximum) {
              totalMax = maximum;
            }
          }

          // Restructure data from 2d array to array of objects
          let datum, metric;
          OLD_DATA = DATA;
          DATA = [];
          for (let i = 0; i < VA_MESSAGE.data.length / numMeasures; i++) {
            // Iterate over each category
            datum = {
              categoryLabel: VA_MESSAGE.data[i * numMeasures][0],
              category: removeSpecialCharacters(
                VA_MESSAGE.data[i * numMeasures][0]
              ),
              metrics: [],
            };

            for (let j = 0; j < numMeasures; j++) {
              // Iterate over  metrics
              metric = {
                category: datum.category,
                metric: VA_MESSAGE.data[i * numMeasures + j][1],
                measure: VA_MESSAGE.data[i * numMeasures + j][2],
                scaled_measure:
                  VA_MESSAGE.data[i * numMeasures + j][2] / totalMax,
                // scaled_measure:
                //   VA_MESSAGE.data[i * numMeasures + j][2] /
                //   METADATA.metrics[VA_MESSAGE.data[i * numMeasures + j][1]]
                //     .maximum,
              };

              datum.metrics.push(metric);
            }

            DATA.push(datum);
          }

          // Get unique categories
          const uniqueCategories = [
            ...new Set(DATA.map((item) => item.category)),
          ];
          const colorCount = uniqueCategories.length;

          // populate the fill colors
          const colorPalette = chroma
            .scale(["#fafa6e", "#2A4858"])
            .mode("lch")
            .colors(colorCount);

          // Iterate over the DATA array
          DATA.forEach((item, index) => {
            // Assign a color to each unique category
            if (!FILL[item.category]) {
              const color = colorPalette[index % colorPalette.length];
              FILL[item.category] = color;
              STROKE[item.category] = chroma(color).darken(0.5).hex();
            }
          });

          // Initialize chart if first draw, otherwise process data and update elements accordingly
          if (d3.select("#" + SVG_ID).empty()) {
            drawElements();
          } else {
            hideTip();
            updateElements();
          }
        }

        // Draw elements for first time and on resize event
        function drawElements() {
          // Return if data is not yet initialized
          if (!DATA) {
            return;
          }

          // Append svg and save reference
          d3.select("body")
            .selectAll("#" + SVG_ID)
            .data([DATA])
            .enter()
            .append("svg")
            .attr("id", SVG_ID)
            .on("click", function () {
              // Deselect legend
              legendDeselectAll();

              // Remove tooltip
              hideTip();
            });

          SVG = d3.select("#" + SVG_ID);

          // Calculate dimensions for graph based on container dimensions
          WIDTH = document.body.clientWidth;
          HEIGHT = document.body.clientHeight;

          // Calculate padding to prevent measure labels from being cutoff
          calculatePadding();

          // Compute the x y locations for legend elements
          calculateLegendDimensions();

          // Create grids if in split mode
          if (SPLIT) {
            gridify();
          }

          // Compute radius using above dimensions
          OLD_RADIUS = RADIUS;
          RADIUS = SPLIT
            ? Math.min(TILE_WIDTH - 2 * SIDE_PAD, TILE_HEIGHT - 2 * TOP_PAD) / 2
            : Math.min(
                WIDTH - 2 * SIDE_PAD,
                HEIGHT - LEG_HEIGHT - 2 * TOP_PAD
              ) / 2;

          // Set SVG width/height using dimensions calculated above
          SVG.style("width", WIDTH).style("height", HEIGHT);

          // Append/update legend group and save reference
          SVG.selectAll(".g-legend")
            .data([DATA])
            .enter()
            .append("g")
            .classed("g-legend", true);

          G_LEGEND = SVG.select(".g-legend");

          // Create legend title
          LEGEND_TITLE = G_LEGEND.selectAll(".legend-title").data([DATA]);

          LEGEND_TITLE.enter()
            .append("text")
            .classed("legend-title", true)
            .text(METADATA.category)
            .merge(LEGEND_TITLE)
            .attr("transform", "translate(" + WIDTH / 2 + ", 0)");

          // Create legend groups
          LEGEND_GROUPS = G_LEGEND.selectAll(".g-legend-entry")
            .data(DATA, function (d) {
              return d.category;
            })
            .enter()
            .append("g")
            .classed("g-legend-entry", true)
            .attr("id", function (d) {
              return d.category + "-legend-entry";
            })
            .on("click", function (d, i) {
              legendSelect(d, i, this);
            });

          G_LEGEND.selectAll(".g-legend-entry")
            .data(DATA, function (d) {
              return d.category;
            })
            .attr("transform", function (d, i) {
              return (
                "translate(" + LEG_EL_POS[i].x + ", " + LEG_EL_POS[i].y + ")"
              );
            });

          // Append legend rects
          LEGEND_GROUPS.append("rect")
            .classed("legend-rect", true)
            .attr("width", LEG_RECT_WIDTH)
            .attr("height", LEG_RECT_WIDTH)
            .attr("fill", function (d) {
              return "url(#" + d.category + "-gradient)";
            })
            .attr("stroke-width", 1)
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            });

          // Append legend texts
          LEGEND_GROUPS.append("text")
            .classed("legend-text", true)
            .text(function (d) {
              return d.categoryLabel;
            })
            .attr("x", LEG_RECT_WIDTH + LEG_RECT_PAD);

          // Set radius using calculated calculate
          G_LEGEND.attr("transform", function () {
            return "translate(0, " + (HEIGHT - LEG_HEIGHT) + ")";
          });

          // Append defs and save reference
          SVG.selectAll(".gradient-defs")
            .data([DATA])
            .enter()
            .append("defs")
            .classed("gradient-defs", true);

          DEFS = SVG.select(".gradient-defs");

          // Create gradients
          GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function (d) {
            return d.category;
          });

          GRADIENTS.enter()
            .append("linearGradient")
            .classed("gradient", true)
            .attr("id", function (d) {
              return d.category + "-gradient";
            })
            .attr("x1", "0%")
            .attr("x2", "100%")
            .attr("y1", "50%")
            .attr("y2", "50%")
            .each(function (d, i) {
              // Append color stops
              d3.select(this)
                .append("stop")
                .attr("class", "start")
                .attr("offset", "0%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 1);

              d3.select(this)
                .append("stop")
                .attr("class", "end")
                .attr("offset", "100%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 0.7);
            });

          // Create group for each category and create subelements within each group
          CATEGORY_GROUPS = SVG.selectAll(".g-category").data(
            DATA,
            function (d) {
              return d.category;
            }
          );

          CATEGORY_GROUPS.enter()
            .append("g")
            .classed("g-category", true)
            .attr("id", function (d) {
              return "g-category-" + d.category;
            })
            .merge(CATEGORY_GROUPS)
            .attr("transform", function (d, i) {
              return SPLIT
                ? "translate(" +
                    ((i % GRID_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2) +
                    ", " +
                    (TOP_PAD +
                      Math.floor(i / GRID_WIDTH) * TILE_HEIGHT +
                      RADIUS) +
                    ")"
                : "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")";
            })
            .each(function (d, i) {
              let categoryGroup = this;
              let iCategory = i;

              // Create grid lines
              GRID_LINES = d3
                .select(categoryGroup)
                .selectAll(".grid-line")
                .data(Object.values(METADATA.metrics), function (d) {
                  return d.metric;
                });

              GRID_LINES.enter()
                .append("line")
                .classed("grid-line", true)
                .attr("stroke", "#C4C4C4")
                .attr("data-angle", function (d) {
                  return d.angle;
                })
                .attr("x1", 0)
                .attr("y1", 0)
                .merge(GRID_LINES)
                .attr("x2", function (d) {
                  return RADIUS * Math.sin(d.angle);
                })
                .attr("y2", function (d) {
                  return -RADIUS * Math.cos(d.angle);
                })
                .style("opacity", function () {
                  return SPLIT || iCategory == 0 ? 1 : 0;
                });

              // Create grid circles
              GRID_CIRCLES = d3
                .select(categoryGroup)
                .selectAll(".grid-circle")
                .data([0.2, 0.4, 0.6, 0.8, 1]);

              GRID_CIRCLES.enter()
                .append("circle")
                .classed("grid-circle", true)
                .attr("fill", "none")
                .attr("stroke", "#E4E4E4")
                .attr("cx", 0)
                .attr("cy", 0)
                .merge(GRID_CIRCLES)
                .attr("r", function (d) {
                  return d * RADIUS;
                })
                .style("opacity", function () {
                  return SPLIT || iCategory == 0 ? 1 : 0;
                });

              // Create measure labels
              MEASURE_LABELS = d3
                .select(categoryGroup)
                .selectAll(".measure-label")
                .data(Object.values(METADATA.metrics), function (d) {
                  return d.metric;
                });

              MEASURE_LABELS.enter()
                .append("text")
                .classed("measure-label", true)
                .text(function (d) {
                  return d.metric;
                })
                .attr("data-angle", function (d) {
                  return d.angle;
                })
                .attr("dx", function (d) {
                  return d.angle == 0 || d.angle == Math.PI
                    ? -this.getBBox().width / 2 + "px"
                    : d.angle > 0 && d.angle < Math.PI
                    ? 0 + "px"
                    : -this.getBBox().width + "px";
                })
                .attr("dy", function (d) {
                  return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                    ? -this.getBBox().height / 2 + "px"
                    : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                    ? 0 + "px"
                    : -this.getBBox().height + "px";
                })
                .merge(MEASURE_LABELS)
                .attr("x", function (d) {
                  return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
                })
                .attr("y", function (d) {
                  return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
                })
                .style("opacity", function () {
                  return SPLIT || iCategory == 0 ? 1 : 0;
                });

              // Create data paths + data points
              DATA_PATHS = d3
                .select(categoryGroup)
                .selectAll(".data-path")
                .data([d], function (d) {
                  return d.category;
                });

              DATA_PATHS.enter()
                .append("path")
                .classed("data-path", true)
                .attr("id", function (d) {
                  return d.category + "-path";
                })
                .attr("fill", function (d, i) {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("fill-opacity", function (d) {
                  return getOpacity(d.category, OPACITY.fill);
                })
                .attr("stroke", function (d, i) {
                  return STROKE[d.category]
                    ? STROKE[d.category]
                    : COLOR_SCALE(i);
                })
                .attr("stroke-opacity", function (d) {
                  return getOpacity(d.category, OPACITY.stroke);
                })
                .merge(DATA_PATHS)
                .attr("d", function (d, i) {
                  const dPath = d;
                  const iPath = i;
                  const points = [];
                  let path = "M ";
                  let x, y;
                  for (let j = 0; j < dPath.metrics.length; j++) {
                    x =
                      RADIUS *
                      dPath.metrics[j].scaled_measure *
                      Math.sin(j * DELTA_ANGLE);
                    y =
                      -RADIUS *
                      dPath.metrics[j].scaled_measure *
                      Math.cos(j * DELTA_ANGLE);
                    points.push({
                      category: dPath.category,
                      metric: dPath.metrics[j].metric,
                      measure: dPath.metrics[j].measure,
                      scaled_measure: dPath.metrics[j].scaled_measure,
                      x: x,
                      y: y,
                    });

                    path +=
                      x +
                      "," +
                      y +
                      (j == dPath.metrics.length - 1 ? " Z" : " L ");
                  }

                  DATA_POINTS = d3
                    .select(categoryGroup)
                    .selectAll(".data-point")
                    .filter(function (d) {
                      return dPath.category == d.category;
                    })
                    .data(points, function (d) {
                      return d.metric;
                    });

                  DATA_POINTS.enter()
                    .append("circle")
                    .classed("data-point", true)
                    .attr(
                      "fill",
                      FILL[dPath.category]
                        ? FILL[dPath.category]
                        : COLOR_SCALE(iPath)
                    )
                    .attr(
                      "fill-opacity",
                      getOpacity(dPath.category, OPACITY.stroke)
                    )
                    .on("click", showTip)
                    .merge(DATA_POINTS)
                    .attr("cx", function (d) {
                      return d.x;
                    })
                    .attr("cy", function (d) {
                      return d.y;
                    })
                    .attr("r", 4);

                  return path;
                });
            });

          // Move tooltip if present
          d3.select(".tip")
            .style("top", function () {
              return RADIUS + TOP_PAD - this.height / 2 + "px";
            })
            .style("left", function () {
              return WIDTH / 2 - this.width / 2 + "px";
            });
        }

        // Redraw data dependent elements on data change
        function updateElements() {
          // Calculate dimensions for graph based on container dimensions
          WIDTH = document.body.clientWidth;
          HEIGHT = document.body.clientHeight;

          // Calculate padding to prevent measure labels from being cutoff
          calculatePadding();

          // Compute the x y locations for legend elements
          calculateLegendDimensions();

          // Create grids if in split mode
          if (SPLIT) {
            gridify();
          }

          // Compute radius using above dimensions
          OLD_RADIUS = RADIUS;
          RADIUS = SPLIT
            ? Math.min(TILE_WIDTH - 2 * SIDE_PAD, TILE_HEIGHT - 2 * TOP_PAD) / 2
            : Math.min(
                WIDTH - 2 * SIDE_PAD,
                HEIGHT - LEG_HEIGHT - 2 * TOP_PAD
              ) / 2;

          // Set SVG width/height using dimensions calculated above
          SVG.style("width", WIDTH).style("height", HEIGHT);

          // Update legend groups
          LEGEND_GROUPS = G_LEGEND.selectAll(".g-legend-entry").data(
            DATA,
            function (d) {
              return d.category;
            }
          );

          // Exit
          LEGEND_GROUPS.exit()
            .each(function () {
              if (d3.select(this).classed("selected")) {
                legendDeselectAll();
              }
            })
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 0)
            .remove();

          // Update
          LEGEND_GROUPS.transition()
            .duration(TRANS_TIME)
            .attr("transform", function (d, i) {
              return (
                "translate(" + LEG_EL_POS[i].x + ", " + LEG_EL_POS[i].y + ")"
              );
            })
            .select("rect")
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            });

          // Enter
          let enter = LEGEND_GROUPS.enter()
            .append("g")
            .classed("g-legend-entry", true)
            .attr("id", function (d) {
              return d.category + "-legend-entry";
            })
            .attr("transform", function (d, i) {
              return (
                "translate(" + LEG_EL_POS[i].x + ", " + LEG_EL_POS[i].y + ")"
              );
            })
            .on("click", function (d, i) {
              legendSelect(d, i, this);
            });

          // Append legend rects
          enter
            .append("rect")
            .classed("legend-rect", true)
            .attr("width", LEG_RECT_WIDTH)
            .attr("height", LEG_RECT_WIDTH)
            .attr("fill", function (d) {
              return "url(#" + d.category + "-gradient)";
            })
            .attr("stroke-width", 1)
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            })
            .style("opacity", 0)
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 1);

          // Append legend texts
          enter
            .append("text")
            .classed("legend-text", true)
            .text(function (d) {
              return d.categoryLabel;
            })
            .attr("x", LEG_RECT_WIDTH + LEG_RECT_PAD)
            .style("opacity", 0)
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 1);

          // Use legend height to determine radius and move legend
          G_LEGEND.transition()
            .duration(TRANS_TIME)
            .attr("transform", function () {
              return "translate(0, " + (HEIGHT - LEG_HEIGHT) + ")";
            });

          // Update gradients
          GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function (d) {
            return d.category;
          });

          GRADIENTS.each(function (d, i) {
            d3.select(this)
              .selectAll("stop")
              .attr("stop-color", function () {
                return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
              });
          });

          GRADIENTS.enter()
            .append("linearGradient")
            .classed("gradient", true)
            .attr("id", function (d) {
              return d.category + "-gradient";
            })
            .attr("x1", "0%")
            .attr("x2", "100%")
            .attr("y1", "50%")
            .attr("y2", "50%")
            .each(function (d, i) {
              // Append color stops
              d3.select(this)
                .append("stop")
                .attr("class", "start")
                .attr("offset", "0%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 1);

              d3.select(this)
                .append("stop")
                .attr("class", "end")
                .attr("offset", "100%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 0.7);
            });

          // Update category groups and all subelements
          CATEGORY_GROUPS = SVG.selectAll(".g-category").data(
            DATA,
            function (d) {
              return d.category;
            }
          );

          CATEGORY_GROUPS.enter()
            .append("g")
            .classed("g-category", true)
            .attr("id", function (d) {
              return "g-category-" + d.category;
            })
            .attr("transform", function (d, i) {
              return SPLIT
                ? "translate(" +
                    ((i % GRID_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2) +
                    ", " +
                    (TOP_PAD +
                      Math.floor(i / GRID_WIDTH) * TILE_HEIGHT +
                      RADIUS) +
                    ")"
                : "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")";
            })
            .each(function (d, i) {
              let categoryGroup = d3.select(this);
              let iCategory = i;

              // Enter grid lines
              GRID_LINES = categoryGroup
                .selectAll(".grid-line")
                .data(Object.values(METADATA.metrics), function (d) {
                  return d.metric;
                });

              GRID_LINES.enter()
                .append("line")
                .classed("grid-line", true)
                .attr("stroke", "#C4C4C4")
                .attr("data-angle", function (d) {
                  return d.angle;
                })
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", function (d) {
                  return RADIUS * Math.sin(d.angle);
                })
                .attr("y2", function (d) {
                  return -RADIUS * Math.cos(d.angle);
                })
                .style("opacity", 0)
                .transition()
                .duration(TRANS_TIME)
                .style("opacity", function () {
                  return SPLIT || iCategory == 0 ? 1 : 0;
                });

              // Enter grid circles
              GRID_CIRCLES = categoryGroup
                .selectAll(".grid-circle")
                .data([0.2, 0.4, 0.6, 0.8, 1]);

              GRID_CIRCLES.enter()
                .append("circle")
                .classed("grid-circle", true)
                .attr("fill", "none")
                .attr("stroke", "#E4E4E4")
                .attr("cx", 0)
                .attr("cy", 0)
                .merge(GRID_CIRCLES)
                .attr("r", function (d) {
                  return d * RADIUS;
                })
                .style("opacity", 0)
                .transition()
                .duration(TRANS_TIME)
                .style("opacity", function () {
                  return SPLIT || iCategory == 0 ? 1 : 0;
                });

              // Enter measure labels
              MEASURE_LABELS = categoryGroup
                .selectAll(".measure-label")
                .data(Object.values(METADATA.metrics), function (d) {
                  return d.metric;
                });

              MEASURE_LABELS.enter()
                .append("text")
                .classed("measure-label", true)
                .text(function (d) {
                  return d.metric;
                })
                .attr("dx", function (d) {
                  return d.angle == 0 || d.angle == Math.PI
                    ? -this.getBBox().width / 2 + "px"
                    : d.angle > 0 && d.angle < Math.PI
                    ? 0 + "px"
                    : -this.getBBox().width + "px";
                })
                .attr("dy", function (d) {
                  return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                    ? -this.getBBox().height / 2 + "px"
                    : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                    ? 0 + "px"
                    : -this.getBBox().height + "px";
                })
                .attr("x", function (d) {
                  return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
                })
                .attr("y", function (d) {
                  return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
                })
                .style("opacity", 0)
                .transition()
                .duration(TRANS_TIME)
                .style("opacity", function () {
                  return SPLIT || iCategory == 0 ? 1 : 0;
                });

              // Enter data paths + data points (Make all points start from 0,0 and go to appropriate location while fading in)
              DATA_PATHS = categoryGroup
                .selectAll(".data-path")
                .data([d], function (d) {
                  return d.category;
                });

              DATA_PATHS.enter()
                .append("path")
                .classed("data-path", true)
                .attr("id", function (d) {
                  return d.category + "-path";
                })
                .attr("fill", function (d, i) {
                  return STROKE[d.category]
                    ? STROKE[d.category]
                    : COLOR_SCALE(i);
                })
                .attr("fill-opacity", function (d) {
                  return getOpacity(d.category, OPACITY.fill);
                })
                .attr("stroke", function (d, i) {
                  return STROKE[d.category]
                    ? STROKE[d.category]
                    : COLOR_SCALE(i);
                })
                .attr("stroke-opacity", function (d) {
                  return getOpacity(d.category, OPACITY.stroke);
                })
                .attr("d", function (d, i) {
                  // Generate actual points while placing path at 0,0
                  const dPath = d;
                  const iPath = i;
                  const points = [];
                  let x, y;
                  let path = "M ";
                  for (let j = 0; j < d.metrics.length; j++) {
                    path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L ");

                    x =
                      RADIUS *
                      dPath.metrics[j].scaled_measure *
                      Math.sin(j * DELTA_ANGLE);
                    y =
                      -RADIUS *
                      dPath.metrics[j].scaled_measure *
                      Math.cos(j * DELTA_ANGLE);
                    points.push({
                      category: dPath.category,
                      metric: dPath.metrics[j].metric,
                      measure: dPath.metrics[j].measure,
                      scaled_measure: dPath.metrics[j].scaled_measure,
                      x: x,
                      y: y,
                    });
                  }

                  DATA_POINTS = categoryGroup
                    .selectAll(".data-point")
                    .filter(function (d) {
                      return dPath.category == d.category;
                    })
                    .data(points, function (d) {
                      return d.metric;
                    });

                  DATA_POINTS.enter()
                    .append("circle")
                    .classed("data-point", true)
                    .attr(
                      "fill",
                      FILL[dPath.category]
                        ? FILL[dPath.category]
                        : COLOR_SCALE(iPath)
                    )
                    .attr(
                      "fill-opacity",
                      getOpacity(dPath.category, OPACITY.stroke)
                    )
                    .on("click", showTip)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .attr("r", 4)
                    .style("opacity", 0);

                  return path;
                })
                .style("opacity", 0)
                .transition()
                .duration(TRANS_TIME)
                .style("opacity", 1)
                .attr("d", function (d) {
                  const dPath = d;
                  const points = [];
                  let path = "M ";
                  let x, y;
                  for (let j = 0; j < dPath.metrics.length; j++) {
                    x =
                      RADIUS *
                      dPath.metrics[j].scaled_measure *
                      Math.sin(j * DELTA_ANGLE);
                    y =
                      -RADIUS *
                      dPath.metrics[j].scaled_measure *
                      Math.cos(j * DELTA_ANGLE);
                    points.push({
                      category: dPath.category,
                      metric: dPath.metrics[j].metric,
                      measure: dPath.metrics[j].measure,
                      scaled_measure: dPath.metrics[j].scaled_measure,
                      x: x,
                      y: y,
                    });

                    path +=
                      x +
                      "," +
                      y +
                      (j == dPath.metrics.length - 1 ? " Z" : " L ");
                  }

                  // Transition data points from 0,0 to proper locations
                  categoryGroup
                    .selectAll(".data-point")
                    .filter(function (d) {
                      return dPath.category == d.category;
                    })
                    .transition()
                    .duration(TRANS_TIME)
                    .attr("cx", function (d) {
                      return d.x;
                    })
                    .attr("cy", function (d) {
                      return d.y;
                    })
                    .style("opacity", 1);

                  return path;
                });
            });

          CATEGORY_GROUPS.each(function (d, i) {
            let categoryGroup = this;
            let iCategory = i;

            // Update grid lines
            GRID_LINES = d3
              .select(categoryGroup)
              .selectAll(".grid-line")
              .data(Object.values(METADATA.metrics), function (d) {
                return d.metric;
              });

            GRID_LINES.enter()
              .append("line")
              .classed("grid-line", true)
              .attr("stroke", "#C4C4C4")
              .attr("data-angle", function (d) {
                return d.angle;
              })
              .attr("x1", 0)
              .attr("y1", 0)
              .attr("x2", function (d) {
                return RADIUS * Math.sin(d.angle);
              })
              .attr("y2", function (d) {
                return -RADIUS * Math.cos(d.angle);
              })
              .style("opacity", 0)
              .transition()
              .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
              .duration(ENTER_REMOVE_TRANS_TIME)
              .style("opacity", function () {
                return SPLIT || iCategory == 0 ? 1 : 0;
              });

            GRID_LINES.transition()
              .duration(TRANS_TIME)
              .style("opacity", function () {
                return SPLIT || iCategory == 0 ? 1 : 0;
              })
              .attrTween("x2", function (d) {
                const startAngle = OLD_METADATA.metrics[d.metric].angle;
                return xTween(OLD_RADIUS, RADIUS, startAngle, d.angle);
              })
              .attrTween("y2", function (d) {
                const startAngle = OLD_METADATA.metrics[d.metric].angle;
                return yTween(OLD_RADIUS, RADIUS, startAngle, d.angle);
              });

            GRID_LINES.exit()
              .transition()
              .duration(ENTER_REMOVE_TRANS_TIME)
              .style("opacity", 0)
              .remove();

            // Update grid circles
            GRID_CIRCLES = d3.select(categoryGroup).selectAll(".grid-circle");

            GRID_CIRCLES.transition()
              .duration(TRANS_TIME)
              .style("opacity", function () {
                return SPLIT || iCategory == 0 ? 1 : 0;
              })
              .attr("r", function (d) {
                return d * RADIUS;
              });

            // Update measure labels
            MEASURE_LABELS = d3
              .select(categoryGroup)
              .selectAll(".measure-label")
              .data(Object.values(METADATA.metrics), function (d) {
                return d.metric;
              });

            MEASURE_LABELS.enter()
              .append("text")
              .classed("measure-label", true)
              .text(function (d) {
                return d.metric;
              })
              .attr("dx", function (d) {
                return d.angle == 0 || d.angle == Math.PI
                  ? -this.getBBox().width / 2 + "px"
                  : d.angle > 0 && d.angle < Math.PI
                  ? 0 + "px"
                  : -this.getBBox().width + "px";
              })
              .attr("dy", function (d) {
                return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                  ? -this.getBBox().height / 2 + "px"
                  : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                  ? 0 + "px"
                  : -this.getBBox().height + "px";
              })
              .attr("x", function (d) {
                return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
              })
              .attr("y", function (d) {
                return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
              })
              .style("opacity", 0)
              .transition()
              .duration(TRANS_TIME)
              .style("opacity", function () {
                return SPLIT || iCategory == 0 ? 1 : 0;
              });

            MEASURE_LABELS.transition()
              .duration(TRANS_TIME)
              .style("opacity", function () {
                return SPLIT || iCategory == 0 ? 1 : 0;
              })
              .attr("dx", function (d) {
                return d.angle == 0 || d.angle == Math.PI
                  ? -this.getBBox().width / 2 + "px"
                  : d.angle > 0 && d.angle < Math.PI
                  ? 0 + "px"
                  : -this.getBBox().width + "px";
              })
              .attr("dy", function (d) {
                return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                  ? -this.getBBox().height / 2 + "px"
                  : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                  ? 0 + "px"
                  : -this.getBBox().height + "px";
              })
              .attrTween("x", function (d) {
                const startAngle = OLD_METADATA.metrics[d.metric].angle;
                return xTween(
                  OLD_RADIUS + MEASURE_LABEL_PADDING,
                  RADIUS + MEASURE_LABEL_PADDING,
                  startAngle,
                  d.angle
                );
              })
              .attrTween("y", function (d) {
                const startAngle = OLD_METADATA.metrics[d.metric].angle;
                return yTween(
                  OLD_RADIUS + MEASURE_LABEL_PADDING,
                  RADIUS + MEASURE_LABEL_PADDING,
                  startAngle,
                  d.angle
                );
              });

            MEASURE_LABELS.exit()
              .transition()
              .duration(ENTER_REMOVE_TRANS_TIME)
              .style("opacity", 0)
              .remove();

            // Update data paths and points
            DATA_PATHS = d3
              .select(categoryGroup)
              .selectAll(".data-path")
              .data([d], function (d) {
                return d.category;
              });

            DATA_PATHS.attr("fill", function (d, i) {
              return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
            })
              .attr("stroke", function (d, i) {
                return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
              })
              .each(function (d) {
                // Find where point was entered/removed and add duplicate point for entered point
                const oldMetrics = Object.values(OLD_METADATA.metrics);
                const metrics = Object.values(METADATA.metrics);
                const oldDelta = Object.values(OLD_METADATA.metrics)[1]
                  ? Object.values(OLD_METADATA.metrics)[1].angle
                  : Math.PI;
                const length = Math.max(oldMetrics.length, metrics.length);
                d.entered = oldMetrics.length < metrics.length;

                // Find where point was added or removed
                for (let j = 0; j < length; j++) {
                  if (
                    !oldMetrics[j] ||
                    !metrics[j] ||
                    oldMetrics[j].metric != metrics[j].metric
                  ) {
                    d.changedIndex = j;
                    break;
                  }
                }

                // If a point was entered, traverse old data and add duplicate point at entered index
                if (d.entered) {
                  d3.select(this).attr("d", function (d) {
                    const oldData = OLD_DATA[iCategory].metrics;
                    let path =
                      d.changedIndex == 0
                        ? "M " +
                          "0," +
                          -RADIUS * oldData[0].scaled_measure +
                          " L "
                        : "M ";
                    let x, y;
                    for (let j = 0; j < oldData.length; j++) {
                      if (d.changedIndex == j + 1) {
                        x =
                          RADIUS *
                          oldData[j].scaled_measure *
                          Math.sin(j * oldDelta);
                        y =
                          -RADIUS *
                          oldData[j].scaled_measure *
                          Math.cos(j * oldDelta);

                        path += x + "," + y + " L ";
                      }

                      x =
                        RADIUS *
                        oldData[j].scaled_measure *
                        Math.sin(j * oldDelta);
                      y =
                        -RADIUS *
                        oldData[j].scaled_measure *
                        Math.cos(j * oldDelta);

                      path +=
                        x + "," + y + (j == oldData.length - 1 ? " Z" : " L ");
                    }
                    return path;
                  });
                }
              })
              .transition()
              .duration(TRANS_TIME)
              .attr("d", function (d, i) {
                // Transition data path to new set of points
                const dPath = d;
                const iPath = i;
                const points = [];
                let path = "M ";
                let x, y;
                for (let j = 0; j < dPath.metrics.length; j++) {
                  if (
                    (!d.entered && d.changedIndex == j) ||
                    (j == dPath.metrics.length - 1 &&
                      d.changedIndex == dPath.metrics.length)
                  ) {
                    // If point was removed create a duplicate for transition
                    x =
                      RADIUS *
                      dPath.metrics[j % dPath.metrics.length].scaled_measure *
                      Math.sin((j % dPath.metrics.length) * DELTA_ANGLE);
                    y =
                      -RADIUS *
                      dPath.metrics[j % dPath.metrics.length].scaled_measure *
                      Math.cos((j % dPath.metrics.length) * DELTA_ANGLE);

                    path += x + "," + y + " L ";
                  }

                  x =
                    RADIUS *
                    dPath.metrics[j].scaled_measure *
                    Math.sin(j * DELTA_ANGLE);
                  y =
                    -RADIUS *
                    dPath.metrics[j].scaled_measure *
                    Math.cos(j * DELTA_ANGLE);
                  points.push({
                    category: dPath.category,
                    metric: dPath.metrics[j].metric,
                    measure: dPath.metrics[j].measure,
                    scaled_measure: dPath.metrics[j].scaled_measure,
                    x: x,
                    y: y,
                  });

                  path +=
                    x +
                    "," +
                    y +
                    (j == dPath.metrics.length - 1 ? " Z" : " L ");
                }

                // Update data points for current category using points array generated above
                DATA_POINTS = d3
                  .select(categoryGroup)
                  .selectAll(".data-point")
                  .filter(function (d) {
                    return dPath.category == d.category;
                  })
                  .data(points, function (d) {
                    return d.metric;
                  });

                DATA_POINTS.attr(
                  "fill",
                  FILL[dPath.category]
                    ? FILL[dPath.category]
                    : COLOR_SCALE(iPath)
                )
                  .transition()
                  .duration(TRANS_TIME)
                  .attr("cx", function (d) {
                    return d.x;
                  })
                  .attr("cy", function (d) {
                    return d.y;
                  });

                DATA_POINTS.enter()
                  .append("circle")
                  .classed("data-point", true)
                  .attr(
                    "fill",
                    FILL[dPath.category]
                      ? FILL[dPath.category]
                      : COLOR_SCALE(iPath)
                  )
                  .attr("cx", function (d) {
                    return d.x;
                  })
                  .attr("cy", function (d) {
                    return d.y;
                  })
                  .attr("r", 4)
                  .attr(
                    "fill-opacity",
                    getOpacity(dPath.category, OPACITY.stroke)
                  )
                  .on("click", showTip)
                  .style("opacity", 0)
                  .transition()
                  .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
                  .duration(ENTER_REMOVE_TRANS_TIME)
                  .style("opacity", 1);

                DATA_POINTS.exit()
                  .transition()
                  .duration(ENTER_REMOVE_TRANS_TIME)
                  .style("opacity", 0)
                  .remove();

                return path;
              })
              .on("end", function (d) {
                // Update data attributes and remove duplicate point if point was removed
                if (!d.entered) {
                  d3.select(this).attr("d", function (d) {
                    let path = "M ";
                    let x, y;
                    for (let j = 0; j < d.metrics.length; j++) {
                      x =
                        RADIUS *
                        d.metrics[j].scaled_measure *
                        Math.sin(j * DELTA_ANGLE);
                      y =
                        -RADIUS *
                        d.metrics[j].scaled_measure *
                        Math.cos(j * DELTA_ANGLE);

                      path +=
                        x +
                        "," +
                        y +
                        (j == d.metrics.length - 1 ? " Z" : " L ");
                    }
                    return path;
                  });
                }
              });
          })
            .transition()
            .duration(TRANS_TIME)
            .attr("transform", function (d, i) {
              return SPLIT
                ? "translate(" +
                    ((i % GRID_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2) +
                    ", " +
                    (TOP_PAD +
                      Math.floor(i / GRID_WIDTH) * TILE_HEIGHT +
                      RADIUS) +
                    ")"
                : "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")";
            });

          CATEGORY_GROUPS.exit()
            .each(function (d, i) {
              let categoryGroup = d3.select(this);
              let iCategory = i;

              // Exit grid lines, grid circles, and measure labels
              categoryGroup
                .selectAll(".grid-line, .grid-circle, .measure-label")
                .transition()
                .duration(TRANS_TIME)
                .style("opacity", 0)
                .remove();

              // Exit data paths + data points (Make all points go to 0,0 and while fading out)
              categoryGroup
                .selectAll(".data-path")
                .each(function (d) {
                  let dPath = d;

                  categoryGroup
                    .selectAll(".data-point")
                    .filter(function (d) {
                      return dPath.category == d.category;
                    })
                    .transition()
                    .duration(TRANS_TIME)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .style("opacity", 0)
                    .remove();
                })
                .transition()
                .duration(TRANS_TIME)
                .attr("d", function (d) {
                  let path = "M ";
                  for (let j = 0; j < d.metrics.length; j++) {
                    path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L ");
                  }
                  return path;
                })
                .style("opacity", 0)
                .remove();
            })
            .transition()
            .duration(TRANS_TIME)
            .remove();
        }

        /******************************************************* Helper Functions *******************************************************/

        // Determine whether or not page is being rendered in iFrame
        function inIframe() {
          try {
            return window.self !== window.top;
          } catch (e) {
            return true;
          }
        }

        // Calculate grid dimensions for split view that maximize room for each chart
        function gridify() {
          const ar = WIDTH / HEIGHT;
          const factors = [];
          const n = DATA.length;
          let gridW, gridH, tileW, tileH, radius;

          for (let i = n; i > 0; i--) {
            gridW = i;
            gridH = Math.ceil(n / i);
            tileW = Math.max(WIDTH / gridW, TILE_MIN_WIDTH);
            tileH = Math.max((HEIGHT - LEG_HEIGHT) / gridH, TILE_MIN_HEIGHT);
            radius = Math.min(tileW - 2 * SIDE_PAD, tileH - 2 * TOP_PAD) / 2;

            factors.push({
              gridW: gridW,
              gridH: gridH,
              tileW: tileW,
              tileH: tileH,
              radius: radius,
            });
          }

          let factor = factors[0];

          for (let i = 1; i < factors.length; i++) {
            if (factors[i].radius > factor.radius) {
              factor = factors[i];
            }
          }

          GRID_WIDTH = factor.gridW;
          GRID_HEIGHT = factor.gridH;
          TILE_WIDTH = Math.max(WIDTH / GRID_WIDTH, TILE_MIN_WIDTH);
          TILE_HEIGHT = Math.max(
            (HEIGHT - LEG_HEIGHT) / GRID_HEIGHT,
            TILE_MIN_HEIGHT
          );
          WIDTH = GRID_WIDTH * TILE_WIDTH;
          HEIGHT = GRID_HEIGHT * TILE_HEIGHT + LEG_HEIGHT;
        }

        // Calculate padding to prevent measure labels from being cutoff
        function calculatePadding() {
          // Create dummy text variable to get measure label widths and height
          let height;
          let width = 0;

          SVG.selectAll(".dummyText")
            .data(Object.values(METADATA.metrics))
            .enter()
            .append("text")
            .classed("measure-label", true)
            .text(function (d) {
              return d.metric;
            })
            .each(function () {
              height = this.getBBox().height;
              width = Math.max(this.getComputedTextLength(), width);
              this.remove();
            });

          SIDE_PAD = width + 2 * MEASURE_LABEL_PADDING;
          TOP_PAD = height + 2 * MEASURE_LABEL_PADDING;
        }

        // Get opacity of data path and data points based on category
        function getOpacity(category, opacity) {
          return SELECTED_CATEGORY
            ? category == SELECTED_CATEGORY
              ? opacity.focus
              : opacity.unfocus
            : opacity.default;
        }

        // Translate SAS format to D3 format
        function translateFormat(formatString) {
          if (formatString.indexOf(".") == formatString.length - 1)
            formatString += 0;

          if (formatString.includes("DOLLAR"))
            return d3.format(
              formatString.replace("DOLLAR", "$").replace(".", ",.") + "f"
            );
          else if (formatString.includes("COMMA"))
            return d3.format(
              formatString.replace("COMMA", "").replace(".", ",.") + "f"
            );
          else if (formatString.includes("F"))
            return d3.format(formatString.replace("F", "") + "f");
          else if (formatString.includes("BEST"))
            return d3.format(formatString.replace("BEST", "") + "f");
          else if (formatString.includes("PERCENT"))
            return d3.format(
              formatString.replace("PERCENT", "").replace(".", ",.") + "%"
            );
        }

        // Deselect all on svg click
        function legendDeselectAll() {
          // Uninitialize selected
          SELECTED_CATEGORY = null;

          // Deselect all legend groups
          G_LEGEND.selectAll(".g-legend-entry").classed("selected", false);

          // Transition all data paths to default opacity
          d3.selectAll(".data-path")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.fill.default)
            .attr("stroke-opacity", OPACITY.stroke.default);

          // Transition all data points to default opacity
          d3.selectAll(".data-point")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.stroke.default);
        }

        // Handle selection on legend group
        function legendSelect(datum, index, el) {
          // Hide tooltip
          hideTip();

          // Change selected to new item
          SELECTED_CATEGORY = datum.category;

          // Prevent event from falling through to underlying elements
          d3.event.stopPropagation();

          // Deselect all legend groups
          G_LEGEND.selectAll(".g-legend-entry").classed("selected", false);

          // Transition all other data paths to unfocus opacity
          d3.selectAll(".data-path")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .filter(function (d) {
              return datum.category != d.category;
            })
            .attr("fill-opacity", OPACITY.fill.unfocus)
            .attr("stroke-opacity", OPACITY.stroke.unfocus);

          // Transition all other data points to unfocus opacity
          d3.selectAll(".data-point")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .filter(function (d) {
              return datum.category != d.category;
            })
            .attr("fill-opacity", OPACITY.stroke.unfocus);

          // Select clicked legend group
          d3.select(el).classed("selected", true);

          // Bring selected data path to front and transition focus opacity
          d3.select("#" + datum.category + "-path")
            .moveToFront()
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.fill.focus)
            .attr("stroke-opacity", OPACITY.stroke.focus);

          // Transition selected data points to focus opacity
          d3.selectAll(".data-point")
            .filter(function (d) {
              return datum.category == d.category;
            })
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.stroke.focus);
        }

        // Determine coordinates for dynamic legend
        function calculateLegendDimensions() {
          // Create dummy text variable to get legend title height
          let titleHeight;
          SVG.selectAll(".dummyText")
            .data([DATA])
            .enter()
            .append("text")
            .classed("legend-text", true)
            .text("TEST")
            .each(function () {
              titleHeight = this.getBBox().height;
              this.remove();
            });

          // Create dummy text variables to get legend text height/widths
          const textWidths = [];
          let textHeight;
          SVG.selectAll(".dummyText")
            .data(DATA)
            .enter()
            .append("text")
            .classed("legend-text", true)
            .text(function (d) {
              return d.category;
            })
            .style("font-weight", "bold")
            .each(function () {
              textHeight = this.getBBox().height;
              textWidths.push(this.getComputedTextLength());
              this.remove();
            });

          // Determine which row each element will sit in and how long each row is
          const rows = [];
          const rowSums = [];
          let rowSum;
          let row = 0;
          for (let i = 0; i < textWidths.length; i++) {
            rowSum =
              textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
            rows.push(row);
            while (
              rowSum +
                textWidths[i + 1] +
                LEG_RECT_WIDTH +
                LEG_RECT_PAD +
                LEG_TEXT_PAD <=
                WIDTH &&
              i + 1 < textWidths.length
            ) {
              i++;
              rowSum +=
                textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
              rows.push(row);
            }
            rowSums.push(rowSum);
            row++;
          }

          // Calculate x and y coordinates for legend elements
          LEG_EL_POS = [];
          for (let i = 0; i < textWidths.length; i++) {
            LEG_EL_POS.push({
              x:
                i == 0 || rows[i - 1] != rows[i]
                  ? WIDTH / 2 - rowSums[rows[i]] / 2
                  : LEG_EL_POS[i - 1].x +
                    textWidths[i - 1] +
                    LEG_RECT_WIDTH +
                    LEG_RECT_PAD +
                    LEG_TEXT_PAD,
              y:
                titleHeight +
                LEG_TITLE_PAD +
                rows[i] * (textHeight + LEG_ROW_PAD),
            });
          }

          // Set legend height
          LEG_HEIGHT =
            LEG_EL_POS[LEG_EL_POS.length - 1].y + textHeight + LEG_ROW_PAD;
        }

        // Tween function for x coordinates on circle
        function xTween(startRadius, endRadius, startAngle, endAngle) {
          const interpolateRadius = d3.interpolate(startRadius, endRadius);
          const interpolateAngle = d3.interpolate(startAngle, endAngle);
          return function (t) {
            const interpolatedRadius = interpolateRadius(t);
            const interpolatedAngle = interpolateAngle(t);
            return interpolatedRadius * Math.sin(interpolatedAngle);
          };
        }

        // Tween functions for y coordinates on circle
        function yTween(startRadius, endRadius, startAngle, endAngle) {
          const interpolateRadius = d3.interpolate(startRadius, endRadius);
          const interpolateAngle = d3.interpolate(startAngle, endAngle);
          return function (t) {
            const interpolatedRadius = interpolateRadius(t);
            const interpolatedAngle = interpolateAngle(t);
            return -interpolatedRadius * Math.cos(interpolatedAngle);
          };
        }

        // Create and fade in tooltip
        function showTip(d) {
          // Prevent event from falling through to underlying elements
          d3.event.stopPropagation();

          // Update tooltips based on clicked data point
          TIPS = d3
            .select("body")
            .selectAll(".tip")
            .data([d], function (d) {
              return d.category + "-" + d.metric;
            });

          TIPS.transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .style("width", "0px")
            .style("height", "0px")
            .remove();

          TIPS.enter()
            .append("div")
            .classed("tip", true)
            .html(function () {
              return (
                "<i class='tip-close fas fa-times'></i>" +
                "<table class='tip-content'> <tr> <td> " +
                METADATA.category +
                ":\t</td> <td>" +
                d.category +
                "</td> </tr>" +
                "<tr> <td> " +
                d.metric +
                ":\t</td> <td>" +
                METADATA.metrics[d.metric].format(d.measure) +
                "</td> </tr>" +
                "<tr> <td> " +
                d.metric +
                " Scaled:\t</td> <td>" +
                SCALED_FORMAT(d.scaled_measure * 100) +
                "</td> </tr> </table>"
              );
            })
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .each(function () {
              this.width = this.clientWidth;
              this.height = this.clientHeight;
            })
            .style("width", "0px")
            .style("height", "0px")
            .transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function () {
              return RADIUS + TOP_PAD - this.height / 2 + "px";
            })
            .style("left", function () {
              return WIDTH / 2 - this.width / 2 + "px";
            })
            .style("width", function () {
              return this.width + "px";
            })
            .style("height", function () {
              return this.height + "px";
            })
            .on("end", function () {
              d3.select(this).select(".tip-close").on("click", hideTip);
            });

          TIPS.exit()
            .transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .style("width", "0px")
            .style("height", "0px")
            .remove();
        }

        // Fade out and remove tooltip
        function hideTip() {
          d3.select(".tip")
            .transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .style("width", "0px")
            .style("height", "0px")
            .remove();
        }
      });
    </script>
  </body>
</html>
