<!DOCTYPE html>
<!--
Copyright 2018 SAS Institute Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
  <head>
    <!-- Import D3.js -->
    <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

    <!-- Import font awesome -->
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
      integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU"
      crossorigin="anonymous"
    />

    <!-- Import utilities  -->
    <script type="text/javascript" src="../util/messagingUtil.js"></script>
    <script type="text/javascript" src="../util/contentUtil.js"></script>
  </head>
  <body>
    <style type="text/css">
      html,
      body,
      svg {
        float: left;
        min-width: 300px;
        min-height: 200px;
        margin: 0px;
        width: 100%;
        height: 100%;
      }

      text {
        font-family: Verdana, sans-serif;
      }

      .data-path {
        pointer-events: none;
        stroke-width: 2;
      }

      .data-point {
        cursor: pointer;
      }

      .legend-title {
        font-size: 0.9em;
        font-weight: bold;
        text-anchor: middle;
        alignment-baseline: hanging;
      }

      .g-legend-entry {
        cursor: pointer;
      }

      .legend-text,
      .measure-label {
        font-size: 0.8em;
        alignment-baseline: hanging;
      }

      .g-legend-entry.selected .legend-text {
        font-weight: bold;
      }

      .g-legend-entry.selected .legend-rect {
        stroke-width: 2px;
      }

      .tip {
        position: absolute;
        display: inline-block;
        overflow: hidden;
        background: white;
        border: 1px solid #c4c4c4;
        box-shadow: 3px 3px 3px #444444;
        border-radius: 2px;
      }

      .tip-close {
        color: #a4a4a4;
        position: absolute;
        cursor: pointer;
        right: 5px;
      }

      .tip-close:hover {
        color: #444444;
      }

      .tip-content {
        margin-top: 10px;
        white-space: nowrap;
        font-family: Verdana, sans-serif;
        font-size: 0.8em;
        text-align: left;
      }
    </style>

    <script>
      "use strict";

      document.addEventListener("DOMContentLoaded", function () {
        /******************************************************* Declare variables *******************************************************/

        // Static data variables
        const SVG_ID = "radar"; // ID of SVG element
        const SAMPLE_MESSAGE = {
          version: "1",
          resultName: "dd55",
          rowCount: 18,
          availableRowCount: 18,
          data: [
            ["Hybrid", "Cylinders", 3.6666666666666665, "BEST12.2"],
            ["Hybrid", "MPG (City)", 55, "BEST12.2"],
            ["Hybrid", "MSRP", 19920, "DOLLAR12.2"],
            ["Sedan", "Cylinders", 5.580152671755725, "BEST12.2"],
            ["Sedan", "MPG (City)", 21.083969465648856, "BEST12.2"],
            ["Sedan", "MSRP", 29773.618320610687, "DOLLAR12.2"],
            ["Sports", "Cylinders", 6.340425531914893, "BEST12.2"],
            ["Sports", "MPG (City)", 18.408163265306122, "BEST12.2"],
            ["Sports", "MSRP", 53387.06122448979, "DOLLAR12.2"],
            ["SUV", "Cylinders", 6.566666666666666, "BEST12.2"],
            ["SUV", "MPG (City)", 16.1, "BEST12.2"],
            ["SUV", "MSRP", 34790.25, "DOLLAR12.2"],
            ["Truck", "Cylinders", 6.25, "BEST12.2"],
            ["Truck", "MPG (City)", 16.5, "BEST12.2"],
            ["Truck", "MSRP", 24941.375, "DOLLAR12.2"],
            ["Wagon", "Cylinders", 5.3, "BEST12.2"],
            ["Wagon", "MPG (City)", 21.1, "BEST12.2"],
            ["Wagon", "MSRP", 28840.533333333333, "DOLLAR12.2"],
          ],
          columns: [
            {
              name: "bi173",
              label: "Type",
              type: "string",
            },
            {
              name: "bi174",
              label: "Metric",
              type: "string",
            },
            {
              name: "bi175",
              label: "Measure",
              type: "number",
              usage: "quantitative",
              aggregation: "sum",
              format: {
                name: "BEST",
                width: 12,
                precision: 0,
                formatString: "BEST12.",
              },
            },
            {
              name: "bi176",
              label: "Format",
              type: "string",
            },
          ],
        }; // Sample data message to render graph outside of VA for debugging
        const OPACITY = {
          fill: {
            focus: 0.6,
            default: 0.2,
            unfocus: 0.1,
          },
          stroke: {
            focus: 1,
            default: 0.6,
            unfocus: 0.2,
          },
        }; // Various opacity values used during rendering
        const FILL = {
          Hybrid: "#21b9b7",
          Sedan: "#4141e0",
          Sports: "#7db71a",
          SUV: "#8e2f8a",
          Truck: "#d38506",
          Wagon: "#0abf85",
        }; // Fill colors keyed to labels
        const STROKE = {
          Hybrid: "#1d9992",
          Sedan: "#2222bc",
          Sports: "#6a9617",
          SUV: "#6d256d",
          Truck: "#ba7006",
          Wagon: "#0a9e69",
        }; // Stroke colors keyed to labels

        // Dynamic data variables
        let VA_MESSAGE; // Data message to be received from VA
        let VA_RESULT_NAME; // Result name required to send messages back to VA
        let DATA; // Data to be parsed from VA data message
        let OLD_DATA; // Data from previous render to track duplicate point
        let METADATA = []; // Metadata to be parsed from VA data message
        let OLD_METADATA; // Metadata from previous render to track duplicate point
        let SELECTED; // Selected rows passed in from VA
        let SELECTED_CATEGORY; // Currently selected category
        let LAST_TRANSITION_END = Date.now(); // Time of last transition used to time transition callbacks

        // Static dimension variables
        const TRANS_TIME = 500; // Duration of major transitions
        const TRANS_DELAY = 20; // Small buffer to ensure all callbacks have finished before allowing new transition
        const HOVER_TRANS_TIME = 100; // Duration of focus transitions
        const ENTER_REMOVE_TRANS_TIME = 200; // Duration of enter and exit transitions for data points and grid lines
        const TIP_TRANS_TIME = 250; // Duration of tooltip transitions
        const MEASURE_LABEL_PADDING = 10; // Padding between edge of radar chart and measure labels
        const LEG_TITLE_PAD = 5; // Padding between legend title bottom and first row of legend
        const LEG_ROW_PAD = 3; // Padding between legend rows
        const LEG_RECT_WIDTH = 12; // Width of legend rects
        const LEG_RECT_PAD = 5; // Padding between legend rect and legend text
        const LEG_TEXT_PAD = 5; // Padding after legend text

        // Dynamic dimension variables
        let WIDTH; // Width of SVG element
        let HEIGHT; // Height of SVG element
        let LEG_EL_POS; // Positions of legend text elements
        let LEG_HEIGHT; // Height allocated for legend
        let RADIUS; // Radius of radar chart
        let OLD_RADIUS; // Previous radius of chart used for tweening height changes
        let DELTA_ANGLE; // Angle in radians between each measure on circle
        let TOP_PAD; // Vertical padding for measure labels
        let SIDE_PAD; // Horizontal padding for measure labels

        // Selection and d3 variables
        const COLOR_SCALE = d3.scaleOrdinal(d3.schemeSet2); // Ordinal color scale as backup
        const SCALED_FORMAT = d3.format("3.0f"); // Format for scaled version of measure displayed in tooltip
        d3.selection.prototype.moveToFront = function () {
          return this.each(function () {
            this.parentNode.appendChild(this);
          });
        }; // Bring element to front of SVG (from https://github.com/wbkd/d3-extended)
        let SVG; // SVG selection
        let DEFS; // Defs element selection
        let G_CHART_AREA; // Chart area group selection
        let G_GRID; // Grid lines group selection
        let G_LEGEND; // Axis label data-join
        let GRADIENTS; // Gradients data-join
        let GRID_LINES; // Grid lines data-join
        let GRID_CIRCLES; // Grid circles data-join
        let MEASURE_LABELS; // Measure labels data-join
        let DATA_PATHS; // Data paths data-join
        let DATA_POINTS; // Data points data-join
        let LEGEND_TITLE; // Legend title data-join
        let LEGEND_GROUPS; // Legend groups data-join
        let TIPS; // Tooltips data-join

        /*************************************************** Setup Callback Functions ***************************************************/

        // Attach event for data message from VA
        va.messagingUtil.setOnDataReceivedCallback(handleCallback);

        // If not being rendered in iFrame (outside VA), render with sample data
        if (!inIframe()) {
          onDataReceived(SAMPLE_MESSAGE);
        }

        // Listen for resize event
        va.contentUtil.setupResizeListener(drawElements);

        /****************************************************** Callback Functions ******************************************************/

        // Use timeouts to debounce update events
        function handleCallback(messageFromVA) {
          if (LAST_TRANSITION_END > Date.now()) {
            setTimeout(function () {
              onDataReceived(messageFromVA);
            }, LAST_TRANSITION_END - Date.now());
            LAST_TRANSITION_END =
              LAST_TRANSITION_END + TRANS_TIME + TRANS_DELAY;
          } else {
            onDataReceived(messageFromVA);
            LAST_TRANSITION_END = Date.now() + TRANS_TIME + TRANS_DELAY;
          }
        }

        // Take action on received data
        function onDataReceived(messageFromVA) {
          // Initialize data variables
          VA_MESSAGE = messageFromVA;
          VA_RESULT_NAME = messageFromVA.resultName;
          SELECTED = va.contentUtil.initializeSelections(messageFromVA);

          // Validate data roles
          if (
            !va.contentUtil.validateRoles(messageFromVA, [
              "string",
              "string",
              "number",
              "string",
            ])
          ) {
            va.messagingUtil.postInstructionalMessage(
              VA_RESULT_NAME,
              "D3 Radar Chart expects columns to be assigned in this order:\n" +
                " 1. Category (string)\n" +
                " 2. Metric (string)\n" +
                " 3. Measure (number)\n" +
                " 4. Format (string)"
            );
            return;
          }

          // Create nest to help process tall data structure
          const nestedData = d3
            .nest()
            .key(function (d) {
              return d[1];
            })
            .entries(VA_MESSAGE.data);
          const numMeasures = nestedData.length;

          // Restructure metadata from data message
          OLD_METADATA = METADATA;
          DELTA_ANGLE = (2 * Math.PI) / numMeasures;

          METADATA = {
            category: VA_MESSAGE.columns[0].label,
            metrics: {},
          };

          for (let i = 0; i < numMeasures; i++) {
            METADATA.metrics[nestedData[i].key] = {
              metric: nestedData[i].key,
              angle: i * DELTA_ANGLE,
              format: translateFormat(VA_MESSAGE.data[i][3]),
              maximum: d3.max(VA_MESSAGE.data, function (d) {
                if (d[1] == nestedData[i].key) {
                  return d[2];
                } else {
                  return Number.MIN_VALUE;
                }
              }),
            };
          }

          // Restructure data from 2d array to array of objects
          let datum, metric;
          OLD_DATA = DATA;
          DATA = [];
          for (let i = 0; i < VA_MESSAGE.data.length / numMeasures; i++) {
            // Iterate over each category
            datum = {
              category: VA_MESSAGE.data[i * numMeasures][0],
              metrics: [],
            };

            for (let j = 0; j < numMeasures; j++) {
              // Iterate over  metrics
              metric = {
                metric: VA_MESSAGE.data[i * numMeasures + j][1],
                measure: VA_MESSAGE.data[i * numMeasures + j][2],
                scaled_measure:
                  VA_MESSAGE.data[i * numMeasures + j][2] /
                  METADATA.metrics[VA_MESSAGE.data[i * numMeasures + j][1]]
                    .maximum,
              };

              datum.metrics.push(metric);
            }

            DATA.push(datum);
          }

          // Initialize chart if first draw, otherwise process data and update elements accordingly
          if (d3.select("#" + SVG_ID).empty()) {
            drawElements();
          } else {
            hideTip();
            updateElements();
          }
        }

        // Draw elements for first time and on resize event
        function drawElements() {
          // Return if data is not yet initialized
          if (!DATA) {
            return;
          }

          // Calculate dimensions for graph based on container dimensions
          WIDTH = document.body.clientWidth;
          HEIGHT = document.body.clientHeight;

          // Append svg and save reference
          d3.select("body")
            .selectAll("#" + SVG_ID)
            .data([DATA])
            .enter()
            .append("svg")
            .attr("id", SVG_ID)
            .on("click", function () {
              // Deselect legend
              legendDeselectAll();

              // Remove tooltip
              hideTip();
            });

          SVG = d3.select("#" + SVG_ID);

          // Calculate padding to prevent measure labels from being cutoff
          calculatePadding();

          // Compute the x y locations for legend elements
          calculateLegendDimensions();

          // Append/update legend group and save reference
          SVG.selectAll(".g-legend")
            .data([DATA])
            .enter()
            .append("g")
            .classed("g-legend", true);

          G_LEGEND = SVG.select(".g-legend");

          // Create legend title
          LEGEND_TITLE = G_LEGEND.selectAll(".legend-title").data([DATA]);

          LEGEND_TITLE.enter()
            .append("text")
            .classed("legend-title", true)
            .text(METADATA.category)
            .merge(LEGEND_TITLE)
            .attr("transform", "translate(" + WIDTH / 2 + ", 0)");

          // Create legend groups
          LEGEND_GROUPS = G_LEGEND.selectAll(".g-legend-entry")
            .data(DATA, function (d) {
              return d.category;
            })
            .enter()
            .append("g")
            .classed("g-legend-entry", true)
            .attr("id", function (d) {
              return d.category + "-legend-entry";
            })
            .on("click", function (d, i) {
              legendSelect(d, i, this);
            });

          G_LEGEND.selectAll(".g-legend-entry")
            .data(DATA, function (d) {
              return d.category;
            })
            .attr("transform", function (d, i) {
              return (
                "translate(" + LEG_EL_POS[i].x + ", " + LEG_EL_POS[i].y + ")"
              );
            });

          // Append legend rects
          LEGEND_GROUPS.append("rect")
            .classed("legend-rect", true)
            .attr("width", LEG_RECT_WIDTH)
            .attr("height", LEG_RECT_WIDTH)
            .attr("fill", function (d) {
              return "url(#" + d.category + "-gradient)";
            })
            .attr("stroke-width", 1)
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            });

          // Append legend texts
          LEGEND_GROUPS.append("text")
            .classed("legend-text", true)
            .text(function (d) {
              return d.category;
            })
            .attr("x", LEG_RECT_WIDTH + LEG_RECT_PAD);

          // Use legend height to determine radius and move legend
          G_LEGEND.attr("transform", function () {
            OLD_RADIUS = RADIUS;
            RADIUS =
              Math.min(
                WIDTH - 2 * SIDE_PAD,
                HEIGHT - LEG_HEIGHT - 2 * TOP_PAD
              ) / 2;
            return "translate(0, " + (HEIGHT - LEG_HEIGHT) + ")";
          });

          // Append defs and save reference
          SVG.selectAll(".gradient-defs")
            .data([DATA])
            .enter()
            .append("defs")
            .classed("gradient-defs", true);

          DEFS = SVG.select(".gradient-defs");

          // Create gradients
          GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function (d) {
            return d.category;
          });

          GRADIENTS.enter()
            .append("linearGradient")
            .classed("gradient", true)
            .attr("id", function (d) {
              return d.category + "-gradient";
            })
            .attr("x1", "0%")
            .attr("x2", "100%")
            .attr("y1", "50%")
            .attr("y2", "50%")
            .each(function (d, i) {
              // Append color stops
              d3.select(this)
                .append("stop")
                .attr("class", "start")
                .attr("offset", "0%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 1);

              d3.select(this)
                .append("stop")
                .attr("class", "end")
                .attr("offset", "100%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 0.7);
            });

          // Append/update chart-area group and save reference
          SVG.selectAll(".g-chart-area")
            .data([DATA])
            .enter()
            .append("g")
            .classed("g-chart-area", true);

          G_CHART_AREA = SVG.select(".g-chart-area").attr(
            "transform",
            "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")"
          );

          // Append/update grid group and save reference
          G_CHART_AREA.selectAll(".g-grid")
            .data([DATA])
            .enter()
            .append("g")
            .classed("g-grid", true);

          G_GRID = G_CHART_AREA.select(".g-grid");

          // Create grid lines
          GRID_LINES = G_GRID.selectAll(".grid-line").data(
            Object.values(METADATA.metrics),
            function (d) {
              return d.metric;
            }
          );

          GRID_LINES.enter()
            .append("line")
            .classed("grid-line", true)
            .attr("stroke", "#C4C4C4")
            .attr("data-angle", function (d) {
              return d.angle;
            })
            .attr("x1", 0)
            .attr("y1", 0)
            .merge(GRID_LINES)
            .attr("x2", function (d) {
              return RADIUS * Math.sin(d.angle);
            })
            .attr("y2", function (d) {
              return -RADIUS * Math.cos(d.angle);
            });

          // Create grid circles
          GRID_CIRCLES = G_GRID.selectAll(".grid-circle").data([
            0.2, 0.4, 0.6, 0.8, 1,
          ]);

          GRID_CIRCLES.enter()
            .append("circle")
            .classed("grid-circle", true)
            .attr("fill", "none")
            .attr("stroke", "#E4E4E4")
            .attr("cx", 0)
            .attr("cy", 0)
            .merge(GRID_CIRCLES)
            .attr("r", function (d) {
              return d * RADIUS;
            });

          // Create measure labels
          MEASURE_LABELS = G_CHART_AREA.selectAll(".measure-label").data(
            Object.values(METADATA.metrics),
            function (d) {
              return d.metric;
            }
          );

          MEASURE_LABELS.enter()
            .append("text")
            .classed("measure-label", true)
            .text(function (d) {
              return d.metric;
            })
            .attr("data-angle", function (d) {
              return d.angle;
            })
            .attr("dx", function (d) {
              return d.angle == 0 || d.angle == Math.PI
                ? -this.getBBox().width / 2 + "px"
                : d.angle > 0 && d.angle < Math.PI
                ? 0 + "px"
                : -this.getBBox().width + "px";
            })
            .attr("dy", function (d) {
              return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                ? -this.getBBox().height / 2 + "px"
                : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                ? 0 + "px"
                : -this.getBBox().height + "px";
            })
            .merge(MEASURE_LABELS)
            .attr("x", function (d) {
              return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
            })
            .attr("y", function (d) {
              return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
            });

          // Create data paths + data points
          DATA_PATHS = G_CHART_AREA.selectAll(".data-path").data(
            DATA,
            function (d) {
              return d.category;
            }
          );

          DATA_PATHS.enter()
            .append("path")
            .classed("data-path", true)
            .attr("id", function (d) {
              return d.category + "-path";
            })
            .attr("fill", function (d, i) {
              return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
            })
            .attr("fill-opacity", function (d) {
              return getOpacity(d.category, OPACITY.fill);
            })
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            })
            .attr("stroke-opacity", function (d) {
              return getOpacity(d.category, OPACITY.stroke);
            })
            .merge(DATA_PATHS)
            .attr("d", function (d, i) {
              const dPath = d;
              const iPath = i;
              const points = [];
              let path = "M ";
              let x, y;
              for (let j = 0; j < dPath.metrics.length; j++) {
                x =
                  RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.sin(j * DELTA_ANGLE);
                y =
                  -RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.cos(j * DELTA_ANGLE);
                points.push({
                  category: dPath.category,
                  metric: dPath.metrics[j].metric,
                  measure: dPath.metrics[j].measure,
                  scaled_measure: dPath.metrics[j].scaled_measure,
                  x: x,
                  y: y,
                });

                path +=
                  x + "," + y + (j == dPath.metrics.length - 1 ? " Z" : " L ");
              }

              DATA_POINTS = G_CHART_AREA.selectAll(".data-point")
                .filter(function (d) {
                  return dPath.category == d.category;
                })
                .data(points, function (d) {
                  return d.metric;
                });

              DATA_POINTS.enter()
                .append("circle")
                .classed("data-point", true)
                .attr(
                  "fill",
                  FILL[dPath.category]
                    ? FILL[dPath.category]
                    : COLOR_SCALE(iPath)
                )
                .attr(
                  "fill-opacity",
                  getOpacity(dPath.category, OPACITY.stroke)
                )
                .on("click", showTip)
                .merge(DATA_POINTS)
                .attr("cx", function (d) {
                  return d.x;
                })
                .attr("cy", function (d) {
                  return d.y;
                })
                .attr("r", 4);

              return path;
            });

          // Move tooltip if present
          d3.select(".tip")
            .style("top", function () {
              return RADIUS + TOP_PAD - this.height / 2 + "px";
            })
            .style("left", function () {
              return WIDTH / 2 - this.width / 2 + "px";
            });
        }

        // Redraw data dependent elements on data change
        function updateElements() {
          // Calculate padding to prevent measure labels from being cutoff
          calculatePadding();

          // Compute the x y locations for legend elements
          calculateLegendDimensions();

          // Update legend groups
          LEGEND_GROUPS = G_LEGEND.selectAll(".g-legend-entry").data(
            DATA,
            function (d) {
              return d.category;
            }
          );

          // Exit
          LEGEND_GROUPS.exit()
            .each(function () {
              if (d3.select(this).classed("selected")) {
                legendDeselectAll();
              }
            })
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 0)
            .remove();

          // Update
          LEGEND_GROUPS.transition()
            .duration(TRANS_TIME)
            .attr("transform", function (d, i) {
              return (
                "translate(" + LEG_EL_POS[i].x + ", " + LEG_EL_POS[i].y + ")"
              );
            })
            .select("rect")
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            });

          // Enter
          let enter = LEGEND_GROUPS.enter()
            .append("g")
            .classed("g-legend-entry", true)
            .attr("id", function (d) {
              return d.category + "-legend-entry";
            })
            .attr("transform", function (d, i) {
              return (
                "translate(" + LEG_EL_POS[i].x + ", " + LEG_EL_POS[i].y + ")"
              );
            })
            .on("click", function (d, i) {
              legendSelect(d, i, this);
            });

          // Append legend rects
          enter
            .append("rect")
            .classed("legend-rect", true)
            .attr("width", LEG_RECT_WIDTH)
            .attr("height", LEG_RECT_WIDTH)
            .attr("fill", function (d) {
              return "url(#" + d.category + "-gradient)";
            })
            .attr("stroke-width", 1)
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            })
            .style("opacity", 0)
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 1);

          // Append legend texts
          enter
            .append("text")
            .classed("legend-text", true)
            .text(function (d) {
              return d.category;
            })
            .attr("x", LEG_RECT_WIDTH + LEG_RECT_PAD)
            .style("opacity", 0)
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 1);

          // Use legend height to determine radius and move legend
          G_LEGEND.transition()
            .duration(TRANS_TIME)
            .attr("transform", function () {
              OLD_RADIUS = RADIUS;
              RADIUS =
                Math.min(
                  WIDTH - 2 * SIDE_PAD,
                  HEIGHT - LEG_HEIGHT - 2 * TOP_PAD
                ) / 2;
              return "translate(0, " + (HEIGHT - LEG_HEIGHT) + ")";
            });

          // Move chart area group
          G_CHART_AREA.transition()
            .duration(TRANS_TIME)
            .attr(
              "transform",
              "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")"
            );

          // Update gradients
          GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function (d) {
            return d.category;
          });

          GRADIENTS.each(function (d, i) {
            d3.select(this)
              .selectAll("stop")
              .attr("stop-color", function () {
                return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
              });
          });

          GRADIENTS.enter()
            .append("linearGradient")
            .classed("gradient", true)
            .attr("id", function (d) {
              return d.category + "-gradient";
            })
            .attr("x1", "0%")
            .attr("x2", "100%")
            .attr("y1", "50%")
            .attr("y2", "50%")
            .each(function (d, i) {
              // Append color stops
              d3.select(this)
                .append("stop")
                .attr("class", "start")
                .attr("offset", "0%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 1);

              d3.select(this)
                .append("stop")
                .attr("class", "end")
                .attr("offset", "100%")
                .attr("stop-color", function () {
                  return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
                })
                .attr("stop-opacity", 0.7);
            });

          // Update grid lines
          GRID_LINES = G_GRID.selectAll(".grid-line").data(
            Object.values(METADATA.metrics),
            function (d) {
              return d.metric;
            }
          );

          GRID_LINES.transition()
            .duration(TRANS_TIME)
            .attrTween("x2", function (d) {
              const startAngle = OLD_METADATA.metrics[d.metric].angle;
              return xTween(OLD_RADIUS, RADIUS, startAngle, d.angle);
            })
            .attrTween("y2", function (d) {
              const startAngle = OLD_METADATA.metrics[d.metric].angle;
              return yTween(OLD_RADIUS, RADIUS, startAngle, d.angle);
            });

          GRID_LINES.enter()
            .append("line")
            .classed("grid-line", true)
            .attr("stroke", "#C4C4C4")
            .attr("data-angle", function (d) {
              return d.angle;
            })
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", function (d) {
              return RADIUS * Math.sin(d.angle);
            })
            .attr("y2", function (d) {
              return -RADIUS * Math.cos(d.angle);
            })
            .style("opacity", 0)
            .transition()
            .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
            .duration(ENTER_REMOVE_TRANS_TIME)
            .style("opacity", 1);

          GRID_LINES.exit()
            .transition()
            .duration(ENTER_REMOVE_TRANS_TIME)
            .style("opacity", 0)
            .remove();

          // Update grid circles
          GRID_CIRCLES = G_GRID.selectAll(".grid-circle");

          GRID_CIRCLES.transition()
            .duration(TRANS_TIME)
            .attr("r", function (d) {
              return d * RADIUS;
            });

          // Update measure labels
          MEASURE_LABELS = G_CHART_AREA.selectAll(".measure-label").data(
            Object.values(METADATA.metrics),
            function (d) {
              return d.metric;
            }
          );

          MEASURE_LABELS.transition()
            .duration(TRANS_TIME)
            .attr("dx", function (d) {
              return d.angle == 0 || d.angle == Math.PI
                ? -this.getBBox().width / 2 + "px"
                : d.angle > 0 && d.angle < Math.PI
                ? 0 + "px"
                : -this.getBBox().width + "px";
            })
            .attr("dy", function (d) {
              return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                ? -this.getBBox().height / 2 + "px"
                : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                ? 0 + "px"
                : -this.getBBox().height + "px";
            })
            .attrTween("x", function (d) {
              const startAngle = OLD_METADATA.metrics[d.metric].angle;
              return xTween(
                OLD_RADIUS + MEASURE_LABEL_PADDING,
                RADIUS + MEASURE_LABEL_PADDING,
                startAngle,
                d.angle
              );
            })
            .attrTween("y", function (d) {
              const startAngle = OLD_METADATA.metrics[d.metric].angle;
              return yTween(
                OLD_RADIUS + MEASURE_LABEL_PADDING,
                RADIUS + MEASURE_LABEL_PADDING,
                startAngle,
                d.angle
              );
            });

          MEASURE_LABELS.enter()
            .append("text")
            .classed("measure-label", true)
            .text(function (d) {
              return d.metric;
            })
            .attr("dx", function (d) {
              return d.angle == 0 || d.angle == Math.PI
                ? -this.getBBox().width / 2 + "px"
                : d.angle > 0 && d.angle < Math.PI
                ? 0 + "px"
                : -this.getBBox().width + "px";
            })
            .attr("dy", function (d) {
              return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
                ? -this.getBBox().height / 2 + "px"
                : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
                ? 0 + "px"
                : -this.getBBox().height + "px";
            })
            .attr("x", function (d) {
              return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
            })
            .attr("y", function (d) {
              return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
            })
            .style("opacity", 0)
            .transition()
            .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
            .duration(ENTER_REMOVE_TRANS_TIME)
            .style("opacity", 1);

          MEASURE_LABELS.exit()
            .transition()
            .duration(ENTER_REMOVE_TRANS_TIME)
            .style("opacity", 0)
            .remove();

          // Update data paths + data points
          DATA_PATHS = G_CHART_AREA.selectAll(".data-path").data(
            DATA,
            function (d) {
              return d.category;
            }
          );

          DATA_PATHS.attr("fill", function (d, i) {
            return FILL[d.category] ? FILL[d.category] : COLOR_SCALE(i);
          })
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            })
            .each(function (d, i) {
              // Find where point was entered/removed and add duplicate point for entered point
              const oldMetrics = Object.values(OLD_METADATA.metrics);
              const metrics = Object.values(METADATA.metrics);
              const oldDelta = Object.values(OLD_METADATA.metrics)[1]
                ? Object.values(OLD_METADATA.metrics)[1].angle
                : Math.PI;
              const length = Math.max(oldMetrics.length, metrics.length);
              d.entered = oldMetrics.length < metrics.length;

              // Find where point was added or removed
              for (let j = 0; j < length; j++) {
                if (
                  !oldMetrics[j] ||
                  !metrics[j] ||
                  oldMetrics[j].metric != metrics[j].metric
                ) {
                  d.changedIndex = j;
                  break;
                }
              }

              // If a point was entered, traverse old data and add duplicate point at entered index
              if (d.entered) {
                d3.select(this).attr("d", function (d) {
                  const oldData = OLD_DATA[i].metrics;
                  let path =
                    d.changedIndex == 0
                      ? "M " +
                        "0," +
                        -RADIUS * oldData[0].scaled_measure +
                        " L "
                      : "M ";
                  let x, y;
                  for (let j = 0; j < oldData.length; j++) {
                    if (d.changedIndex == j + 1) {
                      x =
                        RADIUS *
                        oldData[j].scaled_measure *
                        Math.sin(j * oldDelta);
                      y =
                        -RADIUS *
                        oldData[j].scaled_measure *
                        Math.cos(j * oldDelta);

                      path += x + "," + y + " L ";
                    }

                    x =
                      RADIUS *
                      oldData[j].scaled_measure *
                      Math.sin(j * oldDelta);
                    y =
                      -RADIUS *
                      oldData[j].scaled_measure *
                      Math.cos(j * oldDelta);

                    path +=
                      x + "," + y + (j == oldData.length - 1 ? " Z" : " L ");
                  }
                  return path;
                });
              }
            })
            .transition()
            .duration(TRANS_TIME)
            .attr("d", function (d, i) {
              // Transition data path to new set of points
              const dPath = d;
              const iPath = i;
              const points = [];
              let path = "M ";
              let x, y;
              for (let j = 0; j < dPath.metrics.length; j++) {
                if (
                  (!d.entered && d.changedIndex == j) ||
                  (j == dPath.metrics.length - 1 &&
                    d.changedIndex == dPath.metrics.length)
                ) {
                  // If point was removed create a duplicate for transition
                  x =
                    RADIUS *
                    dPath.metrics[j % dPath.metrics.length].scaled_measure *
                    Math.sin((j % dPath.metrics.length) * DELTA_ANGLE);
                  y =
                    -RADIUS *
                    dPath.metrics[j % dPath.metrics.length].scaled_measure *
                    Math.cos((j % dPath.metrics.length) * DELTA_ANGLE);

                  path += x + "," + y + " L ";
                }

                x =
                  RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.sin(j * DELTA_ANGLE);
                y =
                  -RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.cos(j * DELTA_ANGLE);
                points.push({
                  category: dPath.category,
                  metric: dPath.metrics[j].metric,
                  measure: dPath.metrics[j].measure,
                  scaled_measure: dPath.metrics[j].scaled_measure,
                  x: x,
                  y: y,
                });

                path +=
                  x + "," + y + (j == dPath.metrics.length - 1 ? " Z" : " L ");
              }

              // Update data points for current category using points array generated above
              DATA_POINTS = G_CHART_AREA.selectAll(".data-point")
                .filter(function (d) {
                  return dPath.category == d.category;
                })
                .data(points, function (d) {
                  return d.metric;
                });

              DATA_POINTS.attr(
                "fill",
                FILL[dPath.category] ? FILL[dPath.category] : COLOR_SCALE(iPath)
              )
                .transition()
                .duration(TRANS_TIME)
                .attr("cx", function (d) {
                  return d.x;
                })
                .attr("cy", function (d) {
                  return d.y;
                });

              DATA_POINTS.enter()
                .append("circle")
                .classed("data-point", true)
                .attr(
                  "fill",
                  FILL[dPath.category]
                    ? FILL[dPath.category]
                    : COLOR_SCALE(iPath)
                )
                .attr("cx", function (d) {
                  return d.x;
                })
                .attr("cy", function (d) {
                  return d.y;
                })
                .attr("r", 4)
                .attr(
                  "fill-opacity",
                  getOpacity(dPath.category, OPACITY.stroke)
                )
                .on("click", showTip)
                .style("opacity", 0)
                .transition()
                .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
                .duration(ENTER_REMOVE_TRANS_TIME)
                .style("opacity", 1);

              DATA_POINTS.exit()
                .transition()
                .duration(ENTER_REMOVE_TRANS_TIME)
                .style("opacity", 0)
                .remove();

              return path;
            })
            .on("end", function (d) {
              // Update data attributes and remove duplicate point if point was removed
              if (!d.entered) {
                d3.select(this).attr("d", function (d) {
                  let path = "M ";
                  let x, y;
                  for (let j = 0; j < d.metrics.length; j++) {
                    x =
                      RADIUS *
                      d.metrics[j].scaled_measure *
                      Math.sin(j * DELTA_ANGLE);
                    y =
                      -RADIUS *
                      d.metrics[j].scaled_measure *
                      Math.cos(j * DELTA_ANGLE);

                    path +=
                      x + "," + y + (j == d.metrics.length - 1 ? " Z" : " L ");
                  }
                  return path;
                });
              }
            });

          // Enter - Make all points start from 0,0 and go to appropriate location while fading in
          DATA_PATHS.enter()
            .append("path")
            .classed("data-path", true)
            .attr("id", function (d) {
              return d.category + "-path";
            })
            .attr("fill", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            })
            .attr("fill-opacity", function (d) {
              return getOpacity(d.category, OPACITY.fill);
            })
            .attr("stroke", function (d, i) {
              return STROKE[d.category] ? STROKE[d.category] : COLOR_SCALE(i);
            })
            .attr("stroke-opacity", function (d) {
              return getOpacity(d.category, OPACITY.stroke);
            })
            .attr("d", function (d, i) {
              // Generate actual points while placing path at 0,0
              const dPath = d;
              const iPath = i;
              const points = [];
              let x, y;
              let path = "M ";
              for (let j = 0; j < d.metrics.length; j++) {
                path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L ");

                x =
                  RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.sin(j * DELTA_ANGLE);
                y =
                  -RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.cos(j * DELTA_ANGLE);
                points.push({
                  category: dPath.category,
                  metric: dPath.metrics[j].metric,
                  measure: dPath.metrics[j].measure,
                  scaled_measure: dPath.metrics[j].scaled_measure,
                  x: x,
                  y: y,
                });
              }

              DATA_POINTS = G_CHART_AREA.selectAll(".data-point")
                .filter(function (d) {
                  return dPath.category == d.category;
                })
                .data(points, function (d) {
                  return d.metric;
                });

              DATA_POINTS.enter()
                .append("circle")
                .classed("data-point", true)
                .attr(
                  "fill",
                  FILL[dPath.category]
                    ? FILL[dPath.category]
                    : COLOR_SCALE(iPath)
                )
                .attr(
                  "fill-opacity",
                  getOpacity(dPath.category, OPACITY.stroke)
                )
                .on("click", showTip)
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("r", 4)
                .style("opacity", 0);

              return path;
            })
            .style("opacity", 0)
            .transition()
            .duration(TRANS_TIME)
            .style("opacity", 1)
            .attr("d", function (d) {
              const dPath = d;
              const points = [];
              let path = "M ";
              let x, y;
              for (let j = 0; j < dPath.metrics.length; j++) {
                x =
                  RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.sin(j * DELTA_ANGLE);
                y =
                  -RADIUS *
                  dPath.metrics[j].scaled_measure *
                  Math.cos(j * DELTA_ANGLE);
                points.push({
                  category: dPath.category,
                  metric: dPath.metrics[j].metric,
                  measure: dPath.metrics[j].measure,
                  scaled_measure: dPath.metrics[j].scaled_measure,
                  x: x,
                  y: y,
                });

                path +=
                  x + "," + y + (j == dPath.metrics.length - 1 ? " Z" : " L ");
              }

              // Transition data points from 0,0 to proper locations
              G_CHART_AREA.selectAll(".data-point")
                .filter(function (d) {
                  return dPath.category == d.category;
                })
                .transition()
                .duration(TRANS_TIME)
                .attr("cx", function (d) {
                  return d.x;
                })
                .attr("cy", function (d) {
                  return d.y;
                })
                .style("opacity", 1);

              return path;
            });

          // Exit - Make all points go to 0,0 and while fading out
          DATA_PATHS.exit()
            .each(function (d) {
              let dPath = d;

              G_CHART_AREA.selectAll(".data-point")
                .filter(function (d) {
                  return dPath.category == d.category;
                })
                .transition()
                .duration(TRANS_TIME)
                .attr("cx", 0)
                .attr("cy", 0)
                .style("opacity", 0)
                .remove();
            })
            .transition()
            .duration(TRANS_TIME)
            .attr("d", function (d) {
              let path = "M ";
              for (let j = 0; j < d.metrics.length; j++) {
                path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L ");
              }
              return path;
            })
            .style("opacity", 0)
            .remove();
        }

        /******************************************************* Helper Functions *******************************************************/

        // Determine whether or not page is being rendered in iFrame
        function inIframe() {
          try {
            return window.self !== window.top;
          } catch (e) {
            return true;
          }
        }

        // Calculate padding to prevent measure labels from being cutoff
        function calculatePadding() {
          // Create dummy text variable to get measure label widths and HEIGHT
          let height;
          let width = 0;

          SVG.selectAll(".dummyText")
            .data(Object.values(METADATA.metrics))
            .enter()
            .append("text")
            .classed("measure-label", true)
            .text(function (d) {
              return d.metric;
            })
            .each(function () {
              height = this.getBBox().height;
              width = Math.max(this.getComputedTextLength(), width);
              this.remove();
            });

          SIDE_PAD = width + 2 * MEASURE_LABEL_PADDING;
          TOP_PAD = height + 2 * MEASURE_LABEL_PADDING;
        }

        // Get opacity of data path and data points based on category
        function getOpacity(category, opacity) {
          return SELECTED_CATEGORY
            ? category == SELECTED_CATEGORY
              ? opacity.focus
              : opacity.unfocus
            : opacity.default;
        }

        // Translate SAS format to D3 format
        function translateFormat(formatString) {
          if (formatString.indexOf(".") == formatString.length - 1)
            formatString += 0;

          if (formatString.includes("DOLLAR"))
            return d3.format(
              formatString.replace("DOLLAR", "$").replace(".", ",.") + "f"
            );
          else if (formatString.includes("COMMA"))
            return d3.format(
              formatString.replace("COMMA", "").replace(".", ",.") + "f"
            );
          else if (formatString.includes("F"))
            return d3.format(formatString.replace("F", "") + "f");
          else if (formatString.includes("BEST"))
            return d3.format(formatString.replace("BEST", "") + "f");
          else if (formatString.includes("PERCENT"))
            return d3.format(
              formatString.replace("PERCENT", "").replace(".", ",.") + "%"
            );
        }

        // Deselect all on svg click
        function legendDeselectAll() {
          // Uninitialize selected
          SELECTED_CATEGORY = null;

          // Deselect all legend groups
          G_LEGEND.selectAll(".g-legend-entry").classed("selected", false);

          // Transition all data paths to default opacity
          d3.selectAll(".data-path")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.fill.default)
            .attr("stroke-opacity", OPACITY.stroke.default);

          // Transition all data points to default opacity
          d3.selectAll(".data-point")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.stroke.default);
        }

        // Handle selection on legend group
        function legendSelect(datum, index, el) {
          // Hide tooltip
          hideTip();

          // Change selected to new item
          SELECTED_CATEGORY = datum.category;

          // Prevent event from falling through to underlying elements
          d3.event.stopPropagation();

          // Deselect all legend groups
          G_LEGEND.selectAll(".g-legend-entry").classed("selected", false);

          // Transition all other data paths to unfocus opacity
          d3.selectAll(".data-path")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .filter(function (d) {
              return datum.category != d.category;
            })
            .attr("fill-opacity", OPACITY.fill.unfocus)
            .attr("stroke-opacity", OPACITY.stroke.unfocus);

          // Transition all other data points to unfocus opacity
          d3.selectAll(".data-point")
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .filter(function (d) {
              return datum.category != d.category;
            })
            .attr("fill-opacity", OPACITY.stroke.unfocus);

          // Select clicked legend group
          d3.select(el).classed("selected", true);

          // Bring selected data path to front and transition focus opacity
          d3.select("#" + datum.category + "-path")
            .moveToFront()
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.fill.focus)
            .attr("stroke-opacity", OPACITY.stroke.focus);

          // Transition selected data points to focus opacity
          d3.selectAll(".data-point")
            .filter(function (d) {
              return datum.category == d.category;
            })
            .transition("select")
            .duration(HOVER_TRANS_TIME)
            .attr("fill-opacity", OPACITY.stroke.focus);
        }

        // Determine coordinates for dynamic legend
        function calculateLegendDimensions() {
          // Create dummy text variable to get legend title height
          let titleHeight;
          SVG.selectAll(".dummyText")
            .data([DATA])
            .enter()
            .append("text")
            .classed("legend-text", true)
            .text("TEST")
            .each(function () {
              titleHeight = this.getBBox().height;
              this.remove();
            });

          // Create dummy text variables to get legend text height/widths
          const textWidths = [];
          let textHeight;
          SVG.selectAll(".dummyText")
            .data(DATA)
            .enter()
            .append("text")
            .classed("legend-text", true)
            .text(function (d) {
              return d.category;
            })
            .style("font-weight", "bold")
            .each(function () {
              textHeight = this.getBBox().height;
              textWidths.push(this.getComputedTextLength());
              this.remove();
            });

          // Determine which row each element will sit in and how long each row is
          const rows = [];
          const rowSums = [];
          let rowSum;
          let row = 0;
          for (let i = 0; i < textWidths.length; i++) {
            rowSum =
              textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
            rows.push(row);
            while (
              rowSum +
                textWidths[i + 1] +
                LEG_RECT_WIDTH +
                LEG_RECT_PAD +
                LEG_TEXT_PAD <=
                WIDTH &&
              i + 1 < textWidths.length
            ) {
              i++;
              rowSum +=
                textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
              rows.push(row);
            }
            rowSums.push(rowSum);
            row++;
          }

          // Calculate x and y coordinates for legend elements
          LEG_EL_POS = [];
          for (let i = 0; i < textWidths.length; i++) {
            LEG_EL_POS.push({
              x:
                i == 0 || rows[i - 1] != rows[i]
                  ? WIDTH / 2 - rowSums[rows[i]] / 2
                  : LEG_EL_POS[i - 1].x +
                    textWidths[i - 1] +
                    LEG_RECT_WIDTH +
                    LEG_RECT_PAD +
                    LEG_TEXT_PAD,
              y:
                titleHeight +
                LEG_TITLE_PAD +
                rows[i] * (textHeight + LEG_ROW_PAD),
            });
          }

          // Set legend height
          LEG_HEIGHT =
            LEG_EL_POS[LEG_EL_POS.length - 1].y + textHeight + LEG_ROW_PAD;
        }

        // Tween function for x coordinates on circle
        function xTween(startRadius, endRadius, startAngle, endAngle) {
          const interpolateRadius = d3.interpolate(startRadius, endRadius);
          const interpolateAngle = d3.interpolate(startAngle, endAngle);
          return function (t) {
            const interpolatedRadius = interpolateRadius(t);
            const interpolatedAngle = interpolateAngle(t);
            return interpolatedRadius * Math.sin(interpolatedAngle);
          };
        }

        // Tween functions for y coordinates on circle
        function yTween(startRadius, endRadius, startAngle, endAngle) {
          const interpolateRadius = d3.interpolate(startRadius, endRadius);
          const interpolateAngle = d3.interpolate(startAngle, endAngle);
          return function (t) {
            const interpolatedRadius = interpolateRadius(t);
            const interpolatedAngle = interpolateAngle(t);
            return -interpolatedRadius * Math.cos(interpolatedAngle);
          };
        }

        // Create and fade in tooltip
        function showTip(d) {
          // Prevent event from falling through to underlying elements
          d3.event.stopPropagation();

          // Update tooltips based on clicked data point
          TIPS = d3
            .select("body")
            .selectAll(".tip")
            .data([d], function (d) {
              return d.category + "-" + d.metric;
            });

          TIPS.transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .style("width", "0px")
            .style("height", "0px")
            .remove();

          TIPS.enter()
            .append("div")
            .classed("tip", true)
            .html(function () {
              return (
                "<i class='tip-close fas fa-times'></i>" +
                "<table class='tip-content'> <tr> <td> " +
                METADATA.category +
                ":\t</td> <td>" +
                d.category +
                "</td> </tr>" +
                "<tr> <td> " +
                d.metric +
                ":\t</td> <td>" +
                METADATA.metrics[d.metric].format(d.measure) +
                "</td> </tr>" +
                "<tr> <td> " +
                d.metric +
                " Scaled:\t</td> <td>" +
                SCALED_FORMAT(d.scaled_measure * 100) +
                "</td> </tr> </table>"
              );
            })
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .each(function () {
              this.width = this.clientWidth;
              this.height = this.clientHeight;
            })
            .style("width", "0px")
            .style("height", "0px")
            .transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function () {
              return RADIUS + TOP_PAD - this.height / 2 + "px";
            })
            .style("left", function () {
              return WIDTH / 2 - this.width / 2 + "px";
            })
            .style("width", function () {
              return this.width + "px";
            })
            .style("height", function () {
              return this.height + "px";
            })
            .on("end", function () {
              d3.select(this).select(".tip-close").on("click", hideTip);
            });

          TIPS.exit()
            .transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .style("width", "0px")
            .style("height", "0px")
            .remove();
        }

        // Fade out and remove tooltip
        function hideTip() {
          d3.select(".tip")
            .transition()
            .duration(TIP_TRANS_TIME)
            .style("top", function (d) {
              return RADIUS + TOP_PAD + d.y + "px";
            })
            .style("left", function (d) {
              return WIDTH / 2 + d.x + "px";
            })
            .style("width", "0px")
            .style("height", "0px")
            .remove();
        }
      });
    </script>
  </body>
</html>
